<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>学习数据结构和算法</title>
</head>

<body>

    <head>
        <h1>学习数据结构和算法</h1>
    </head>
    <main>
        <section>
            <h2>第一章: javascript简介</h2>
            <ul>
                <li>
                    <p>变量声明：</p>
                    <p>var，var有全局作用域和函数作用域，存在变量提升。</p>
                </li>
                <li>
                    <p>数据类型：</p>
                    <p>null、undefined、boolean、number、string、symbol、bigint、object，object是引用类型，其他是原始类型，原始类型调用原型方法时自动使用对应的实例包装。
                    </p>
                </li>
                <li>
                    <p>算数运算符：</p>
                    <p><code>+、-、*、/、%、++、--</code></p>
                </li>
                <li>
                    <p>赋值运算符：</p>
                    <p><code>=、+=、-=、*=、/=、%-</code></p>
                </li>
                <li>
                    <p>比较运算符：</p>
                    <p><code>==、===、!=、>、>=、<、<=</code></p>
                </li>
                <li>
                    <p>逻辑运算符：</p>
                    <p>&&、||、!</p>
                </li>
                <li>
                    <p>位运算符：</p>
                    <p><code>&、|、~、^、<<、>></code></p>
                </li>
                <li>
                    <p>==比较：</p>
                    <p>不同类型值比较会产生类型转换 toString()、toNumber()、toPrimitive()、valueOf()</p>
                </li>
                <li>
                    <p>===比较：</p>
                    <p>须类型相同值相同，不会产生类型转换。</p>
                </li>
                <li>
                    <p>控制结构：</p>
                    <p>if、else、else if、switch、condition?statement:statement</p>
                </li>
                <li>
                    <p>循环: </p>
                    <p>for、while、do...while</p>
                </li>
                <li>
                    <p>函数：</p>
                    <p><code>function adder(a){return a+1}</code>,<code>(function(){console.log(1)})()</code></p>
                </li>
                <li>
                    <p>面向对象编程：</p>
                    <p>构造函数（使用 new
                        关键字进行实例化）、原型(原型是一种在实例中共享属性和方法的机制，构造函数的实例中存在对原型的隐式引用，访问实例的属性和方法通过原型链进行查找直到找到方法或属性或者查找到null,返回undefined)
                    </p>
                </li>
                <li>
                    <p>调试工具：</p>
                    <p>Chrome、VSCode</p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第二章：ECMAScript和TypeScript</h2>
            <ul>
                <li>
                    <p>ECMAScript是标准，javascript是实现。</p>
                </li>
                <li>
                    <p>let、const：</p>
                    <p>代替var，拥有块级作用域，没有变量提升，存在暂时性死区。</p>
                </li>
                <li>
                    <p>模板字符串：</p>
                    <p><code>const str=`1${2}34`</code></p>
                </li>
                <li>
                    <p>箭头函数：</p>
                    <p><code>()=>{}</code></p>
                </li>
                <li>
                    <p>函数默认参数：</p>
                    <p><code>const fn1=(a=1)=>a+1;</code></p>
                </li>
                <li>
                    <p>展开和剩余参数：</p>
                    <p><code>const fn1=(a,b,...args)=> Math.max(a,b,...args)</code></p>
                </li>
                <li>
                    <p>解构赋值：</p>
                    <p><code>const [a,b]=[1,2]; const {a,b}={a:3,b:4};</code></p>
                </li>
                <li>
                    <p>属性简写：</p>
                    <p><code>let b=2; const obj={a(){},b};</code></p>
                </li>
                <li>
                    <p>使用类进行面向对象编程：</p>
                    <p>class、constructor、#privateValue、static、get、set</p>
                </li>
                <li>
                    <p>继承：</p>
                    <p>extends， super </p>
                </li>
                <li>
                    <p>乘方运算：</p>
                    <p><code>const cube=(val) => val**3;</code></p>
                </li>
                <li>
                    <p>模块：</p>
                    <p>export、export default、export * from 、import * as tools from 'tools.js'、import {val1 as a} from
                        'a.js'、import defaultValue from 'default.js'；浏览器中运行模块须在script标签上加type="module"。向后兼容需要加nomodule属性
                    </p>
                </li>
                <li>
                    <p>TypeScript：</p>
                    <p>类型推断、接口、泛型</p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第三章：数组</h2>
            <ul>
                <li>
                    <p>初始化数组：</p>
                    <p><code>let arr1=[];let arr2=new Array(1); let arr3=new Array(1,2,3,4,5);</code></p>
                </li>
                <li>
                    <p>访问元素、迭代元素：</p>
                    <p>使用arr[index]访问元素，使用for、for of迭代。</p>
                </li>
                <li>
                    <p>添加元素：</p>
                    <p>push、unshift、splice</p>
                </li>
                <li>
                    <p>删除元素：</p>
                    <p>pop、shift、splice</p>
                </li>
                <li>
                    <p>多维数组：</p>
                    <p>多嵌套数组，使用迭代、递归进行操作。 </p>
                </li>
                <li>
                    <p>数组参考方法：</p>
                    <p>
                        原型方法：forEach、map、filter、sort、reduce、slice、reverse、join、some、every、includes、find、indexOf,lastIndexOf<br />
                        静态方法：from、isArray、of
                    </p>
                </li>
                <li>
                    <p>数组合并：</p>
                    <p><code>let arr1=[1,2]; let arr2=[3,4]; let arr3=arr1.concat(arr2); let arr4=[...arr1,...arr2];</code>
                    </p>
                </li>
                <li>
                    <p>类型数组：</p>
                    <p>配合ArrayBuffer使用，读取二进制数据。</p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第四章：栈</h2>
            <ul>
                <li>
                    <p>基于数组的栈：</p>
                    <p>
                        <code>
                            class Stack{

                                constructor(){
                                    this.items=[];
                                }

                                push(element){
                                    this.items.push(element);
                                }

                                pop(){
                                    return this.items.pop();
                                }

                                peek(){
                                    return this.items[this.items.length-1]
                                }

                                isEmpty(){
                                    return this.items.length===0;
                                }

                                clear(){
                                    this.items=[];
                                }
                            }

                            const stack=new Stack();
                            console.log(stack.isEmpty());
                            stack.push(1);
                            stack.push(2);
                            console.log(stack.peek());
                            stack.pop();
                            console.log(stack.peek());
                            console.log(stack.isEmpty());
                        </code>
                    </p>
                </li>
                <li>
                    <p>基于对象的栈：</p>
                    <p>
                        <code>
                        class Stack{
                            constructor(){
                                this.count=0;
                                this.items={};
                            }

                            push(element){
                                this.items[this.count]=element;
                                this.count++;
                            }

                            pop(){
                                if(this.isEmpty()){
                                    return undefined;
                                }
                                this.count--;
                                let element=this.items[this.count];
                                delete this.items[this.count];
                                return element;
                            }

                            peek(){
                                if(this.isEmpty()){
                                    return undefined;
                                }
                                return this.items[this.count-1];
                            }

                            isEmpty(){
                                return this.count===0;
                            }

                            clear(){
                                while(!this.isEmpty()){
                                    this.pop();
                                }
                            }

                            toString(){
                                if(this.isEmpty()){
                                    return "";
                                }
                                let str=`${this.items[0]}`;
                                for(let i=1; i < this.count; i++){
                                    str=`${str},${this.items[i]}`
                                }
                                return str;
                            }
                        }
                    </code>
                    </p>
                </li>
                <li>
                    <p>进制转换：</p>
                    <p>
                        <code>
                            class Stack{
                                constructor(){
                                    this.count=0;
                                    this.items={};
                                }
    
                                push(element){
                                    this.items[this.count]=element;
                                    this.count++;
                                }
    
                                pop(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    this.count--;
                                    let element=this.items[this.count];
                                    delete this.items[this.count];
                                    return element;
                                }
    
                                peek(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    return this.items[this.count-1];
                                }
    
                                isEmpty(){
                                    return this.count===0;
                                }
    
                                clear(){
                                    while(!this.isEmpty()){
                                        this.pop();
                                    }
                                }
    
                                toString(){
                                    if(this.isEmpty()){
                                        return "";
                                    }
                                    let str=`${this.items[0]}`;
                                    for(let i=1; i < this.count; i++){
                                        str=`${str},${this.items[i]}`
                                    }
                                    return str;
                                }
                            }
                            function baseConverter(decNumber, base) { 
                                const remStack = new Stack(); 
                                const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                                let number = decNumber; 
                                let rem; 
                                let baseString = ''; 

                                if (!(base >= 2 && base <= 36)) { 
                                    return ''; 
                                }

                                while (number > 0) { 
                                    rem = Math.floor(number % base); 
                                    remStack.push(rem); 
                                    number = Math.floor(number / base); 
                                }

                                while (!remStack.isEmpty()) { 
                                    baseString += digits[remStack.pop()]; 
                                } 

                                return baseString; 
                            }
                        </code>
                    </p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第五章：队列和双端队列</h2>
            <ul>
                <li>
                    <p>队列：</p>
                    <p>
                        <code>
                            class Queue{
                                constructor(){
                                    this.count=0;
                                    this.lowestCount=0;
                                    this.items={};
                                }

                                enqueue(item){
                                    this.items[this.count]=item;
                                    this.count++;
                                }

                                dequeue(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    let res=this.items[this.lowestCount];
                                    delete this.items[this.lowestCount];
                                    this.lowestCount++;
                                    return res;
                                }

                                peek(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    return this.items[this.lowestCount];
                                }
                                
                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count-this.lowestCount;
                                }

                                clear(){
                                    this.count=0;
                                    this.lowestCount=0;
                                    this.items={};
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return "";
                                    }
                                    let str=`${this.items[this.lowestCount]}`;
                                    for(let i = this.lowestCount+1; i < this.count ; i++){
                                        str=`${str},${this.items[i]}`;
                                    }
                                    return str;
                                }
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>双端队列：</p>
                    <p>
                        <code>
                            class Deque{
                                constructor(){
                                    this.count=0;
                                    this.lowestCount=0;
                                    this.items={};
                                }

                                addFront(item){
                                    if(this.isEmpty()){
                                        this.addBack(item);
                                    }else if (this.lowestCount>0){
                                        this.lowestCount--;
                                        this.items[this.lowestCount]=item;
                                    }else{
                                        for(let i=this.count; i > 0; i--){
                                            this.items[i]=this.items[i-1];
                                        }
                                        this.count++;
                                        this.items[0]=item;
                                    }                                
                                }

                                addBack(item){
                                    this.items[this.count]=item;
                                    this.count++; 
                                }

                                removeFront(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    let res=this.items[this.lowestCount];
                                    delete this.items[this.lowestCount];
                                    this.lowestCount++;
                                    return res;
                                }

                                removeBack(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    let res= this.items[this.count-1];
                                    delete this.items[this.count-1];
                                    this.count--;
                                    return res;
                                }

                                peekFront(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    return this.items[this.lowestCount];
                                }

                                peekBack(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    return this.items[this.count-1];
                                }

                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count-this.lowestCount;
                                }

                                clear(){
                                    this.count=0;
                                    this.lowestCount=0;
                                    this.items={};
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return "";
                                    }
                                    let str=`${this.items[this.lowestCount]}`;
                                    for(let i = this.lowestCount+1; i < this.count ; i++){
                                        str = `${str},${this.items[i]}`;
                                    }
                                    return str;
                                }
                            }                           
                        </code>
                    </p>
                </li>
                <li>
                    <p>循环队列击鼓传花：</p>
                    <p>
                        <code>
                            class Queue{
                                constructor(){
                                    this.count=0;
                                    this.lowestCount=0;
                                    this.items={};
                                }

                                enqueue(item){
                                    this.items[this.count]=item;
                                    this.count++;
                                }

                                dequeue(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    let res=this.items[this.lowestCount];
                                    delete this.items[this.lowestCount];
                                    this.lowestCount++;
                                    return res;
                                }

                                peek(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    return this.items[this.lowestCount];
                                }
                                
                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count-this.lowestCount;
                                }

                                clear(){
                                    this.count=0;
                                    this.lowestCount=0;
                                    this.items={};
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return "";
                                    }
                                    let str=`${this.items[this.lowestCount]}`;
                                    for(let i = this.lowestCount+1; i < this.count ; i++){
                                        str=`${str},${this.items[i]}`;
                                    }
                                    return str;
                                }
                            }
                            function hotPotato(elementsList, num) { 
                                const queue = new Queue(); 
                                const elimitatedList = []; 
                                for (let i = 0; i < elementsList.length; i++) { 
                                    queue.enqueue(elementsList[i]); 
                                } 
                                while (queue.size() > 1) { 
                                    for (let i = 0; i < num; i++) { 
                                        queue.enqueue(queue.dequeue()); 
                                    } 
                                    elimitatedList.push(queue.dequeue());
                                } 
                                return { 
                                    eliminated: elimitatedList, 
                                    winner: queue.dequeue()
                                }; 
                            }
                            result.eliminated.forEach(name => { 
                                console.log(`${name}在击鼓传花游戏中被淘汰。`); 
                            }); 
                            console.log(`胜利者： ${result.winner}`);
                        </code>
                    </p>
                </li>
                <li>
                    <p>回文数检测：</p>
                    <p>
                        <code>
                            class Deque{
                                constructor(){
                                    this.count=0;
                                    this.lowestCount=0;
                                    this.items={};
                                }

                                addFront(item){
                                    if(this.isEmpty()){
                                        this.addBack(item);
                                    }else if (this.lowestCount>0){
                                        this.lowestCount--;
                                        this.items[this.lowestCount]=item;
                                    }else{
                                        for(let i=this.count; i > 0; i--){
                                            this.items[i]=this.items[i-1];
                                        }
                                        this.count++;
                                        this.items[0]=item;
                                    }                                
                                }

                                addBack(item){
                                    this.items[this.count]=item;
                                    this.count++; 
                                }

                                removeFront(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    let res=this.items[this.lowestCount];
                                    delete this.items[this.lowestCount];
                                    this.lowestCount++;
                                    return res;
                                }

                                removeBack(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    let res= this.items[this.count-1];
                                    delete this.items[this.count-1];
                                    this.count--;
                                    return res;
                                }

                                peekFront(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    return this.items[this.lowestCount];
                                }

                                peekBack(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    return this.items[this.count-1];
                                }

                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count-this.lowestCount;
                                }

                                clear(){
                                    this.count=0;
                                    this.lowestCount=0;
                                    this.items={};
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return "";
                                    }
                                    let str=`${this.items[this.lowestCount]}`;
                                    for(let i = this.lowestCount+1; i < this.count ; i++){
                                        str = `${str},${this.items[i]}`;
                                    }
                                    return str;
                                }
                            }
                            function palindromeChecker(aString) {
                                if (aString === undefined || aString === null || (aString !== null && aString.length === 0)) { 
                                    return false; 
                                } 
                                const deque = new Deque();
                                const lowerString = aString.toLocaleLowerCase().split(' ').join('');
                                let isEqual = true; 
                                let firstChar, lastChar; 
                                for (let i = 0; i < lowerString.length; i++) {
                                    deque.addBack(lowerString.charAt(i)); 
                                } 
                                while (deque.size() > 1 && isEqual) { 
                                    firstChar = deque.removeFront();
                                    lastChar = deque.removeBack(); 
                                    if (firstChar !== lastChar) { 
                                        isEqual = false; 
                                    } 
                                } 
                                return isEqual; 
                            }
                            console.log('a', palindromeChecker('a')); 
                            console.log('aa', palindromeChecker('aa')); 
                            console.log('kayak', palindromeChecker('kayak')); 
                            console.log('level', palindromeChecker('level')); 
                            console.log('Was it a car or a cat I saw', palindromeChecker('Was it a car or a cat I saw')); 
                            console.log('Step on no pets', palindromeChecker('Step on no pets'));
                        </code>
                    </p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第六章：链表</h2>
            <ul>
                <li>
                    <p>创建链表</p>
                    <p>
                        <code>
                            function defaultEquals(a,b){
                                return a===b;
                            }
                            class Node{
                                constructor(element,next){
                                    this.element=element;
                                    this.next=next;
                                }
                            }
                            class LinkedList{
                                constructor(equalsFn=defaultEquals){
                                    this.count=0;
                                    this.head=undefined;
                                    this.equalsFn=equalsFn;
                                }

                                push(element){
                                    const node = new Node(element);
                                    if(!this.head){
                                        this.head=node;
                                    }else{
                                        let current=this.head;
                                        while(current.next){
                                            current=current.next;
                                        }
                                        current.next=node;
                                    }
                                    this.count++;
                                }
                                
                                insert(element,index){
                                    if(index >= 0 && index <= this.count){
                                        const node = new Node(element);
                                        if(index===0){
                                            node.next=this.head;
                                            this.head=node;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            const current=pervious.next;
                                            node.next=current;
                                            pervious.next=node;
                                        }
                                        this.count++;
                                        return true;
                                    }
                                    return false;
                                }

                                getElementAt(index){
                                    if(index >= 0 && index < this.count){
                                        let node=this.head;
                                        for(let i=0; i < index && node; i++){
                                            node=node.next;
                                        }
                                        return node;
                                    }
                                    return undefined;
                                }

                                remove(element){
                                    const index=this.indexOf(element);
                                    return this.removeAt(index);
                                }

                                indexOf(element){
                                    let current=this.head;
                                    for(let i=0; i < this.count && current; i++){
                                        if(this.equalsFn(current.element,element)){
                                            return i;
                                        }
                                        current=current.next;
                                    }
                                    return -1;
                                }

                                removeAt(index){
                                    if(index >= 0 && index < this.count){
                                        let current=this.head;
                                        if(index===0){
                                            this.head=current.next;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            current=pervious.next;
                                            pervious.next=current.next;
                                        }
                                        this.count--;
                                        return current.element;
                                    }
                                    return undefined;
                                }

                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count;
                                }

                                getHead(){
                                    return this.head;
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return  "";
                                    }
                                    let str=`${this.head.element}`;
                                    let current=this.head.next;
                                    for(let i=1; i < this.count && current; i++){
                                        str=`${str},${current.element}`;
                                        current=current.next;
                                    }
                                    return str;
                                }
                            }                            
                        </code>
                    </p>
                </li>
                <li>
                    <p>双向链表：</p>
                    <p>
                        <code>
                            function defaultEquals(a,b){
                                return a===b;
                            }

                            class Node{
                                constructor(element,next){
                                    this.element=element;
                                    this.next=next;
                                }
                            }

                            class LinkedList{
                                constructor(equalsFn=defaultEquals){
                                    this.count=0;
                                    this.head=undefined;
                                    this.equalsFn=equalsFn;
                                }

                                push(element){
                                    const node = new Node(element);
                                    if(!this.head){
                                        this.head=node;
                                    }else{
                                        let current=this.head;
                                        while(current.next){
                                            current=current.next;
                                        }
                                        current.next=node;
                                    }
                                    this.count++;
                                }
                                
                                insert(element,index){
                                    if(index >= 0 && index <= this.count){
                                        const node = new Node(element);
                                        if(index===0){
                                            node.next=this.head;
                                            this.head=node;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            const current=pervious.next;
                                            node.next=current;
                                            pervious.next=node;
                                        }
                                        this.count++;
                                        return true;
                                    }
                                    return false;
                                }

                                getElementAt(index){
                                    if(index >= 0 && index < this.count){
                                        let node=this.head;
                                        for(let i=0; i < index && node; i++){
                                            node=node.next;
                                        }
                                        return node;
                                    }
                                    return undefined;
                                }

                                remove(element){
                                    const index=this.indexOf(element);
                                    return this.removeAt(index);
                                }

                                indexOf(element){
                                    let current=this.head;
                                    for(let i=0; i < this.count && current; i++){
                                        if(this.equalsFn(current.element,element)){
                                            return i;
                                        }
                                        current=current.next;
                                    }
                                    return -1;
                                }

                                removeAt(index){
                                    if(index >= 0 && index < this.count){
                                        let current=this.head;
                                        if(index===0){
                                            this.head=current.next;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            current=pervious.next;
                                            pervious.next=current.next;
                                        }
                                        this.count--;
                                        return current.element;
                                    }
                                    return undefined;
                                }

                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count;
                                }

                                getHead(){
                                    return this.head;
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return  "";
                                    }
                                    let str=`${this.head.element}`;
                                    let current=this.head.next;
                                    for(let i=1; i < this.count && current; i++){
                                        str=`${str},${current.element}`;
                                        current=current.next;
                                    }
                                    return str;
                                }
                            }  

                            class DoublyNode extends Node{
                                constructor(element,next,prev){
                                    super(element,next);
                                    this.prev=prev;
                                }
                            }

                            class DoublyLinkedList extends LinkedList{
                                constructor(equalsFn=defaultEquals){
                                    super(equalsFn);
                                    this.tail=undefined;
                                }

                                push(element){
                                    const node = new DoublyNode(element);
                                    if(!this.tail){
                                        this.head=node;
                                        this.tail=node;
                                    }else{
                                        let current=this.tail;
                                        current.next=node;
                                        node.prev=current;
                                        this.tail=node;
                                    }
                                    this.count++;
                                }

                                insert(element,index){
                                    if(index >= 0 && index <= this.count){
                                        const node = new DoublyNode(element);
                                        let current = this.head;
                                        if(index===0){
                                            if(!this.head){
                                                this.head=node;
                                                this.tail=node;
                                            }else{
                                                node.next=this.head;
                                                current.prev=node;
                                                this.head=node;
                                            }
                                        } else if (index===this.count){
                                            current=this.tail;
                                            current.next=node;
                                            node.prev=current;
                                            this.tail=node;
                                        }else{
                                            const previous = this.getElementAt(index-1);
                                            current=previous.next;
                                            previous.next=node;
                                            node.prev=previous;
                                            node.next=currnet;
                                            current.prev=node;
                                        }
                                        this.count++;
                                        return true;
                                    }
                                    return false;
                                }

                                removeAt(index){
                                    if(index >=0 && index < this.count){
                                        let current=this.head;
                                        if(index===0){
                                            this.head=this.head.next;
                                            if(this.count===1){
                                                this.tail=undefined;
                                            }else{
                                                this.head.prev=undefined;
                                            }
                                        }else if (index === this.count - 1){
                                            current=this.tail;
                                            this.tail=current.prev;
                                            this.tail.next=undefined;
                                        }else{
                                            current = this.getElementAt(index);
                                            let previous= current.prev;
                                            previous.next=current.next;
                                            current.next.prev=previous;
                                        }
                                        this.count--;
                                        return current.element;
                                    }
                                    return undefined;
                                }
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>循环链表：</p>
                    <p>
                        <code>
                            function defaultEquals(a,b){
                                return a===b;
                            }
                            class Node{
                                constructor(element,next){
                                    this.element=element;
                                    this.next=next;
                                }
                            }
                            class LinkedList{
                                constructor(equalsFn=defaultEquals){
                                    this.count=0;
                                    this.head=undefined;
                                    this.equalsFn=equalsFn;
                                }

                                push(element){
                                    const node = new Node(element);
                                    if(!this.head){
                                        this.head=node;
                                    }else{
                                        let current=this.head;
                                        while(current.next){
                                            current=current.next;
                                        }
                                        current.next=node;
                                    }
                                    this.count++;
                                }
                                
                                insert(element,index){
                                    if(index >= 0 && index <= this.count){
                                        const node = new Node(element);
                                        if(index===0){
                                            node.next=this.head;
                                            this.head=node;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            const current=pervious.next;
                                            node.next=current;
                                            pervious.next=node;
                                        }
                                        this.count++;
                                        return true;
                                    }
                                    return false;
                                }

                                getElementAt(index){
                                    if(index >= 0 && index < this.count){
                                        let node=this.head;
                                        for(let i=0; i < index && node; i++){
                                            node=node.next;
                                        }
                                        return node;
                                    }
                                    return undefined;
                                }

                                remove(element){
                                    const index=this.indexOf(element);
                                    return this.removeAt(index);
                                }

                                indexOf(element){
                                    let current=this.head;
                                    for(let i=0; i < this.count && current; i++){
                                        if(this.equalsFn(current.element,element)){
                                            return i;
                                        }
                                        current=current.next;
                                    }
                                    return -1;
                                }

                                removeAt(index){
                                    if(index >= 0 && index < this.count){
                                        let current=this.head;
                                        if(index===0){
                                            this.head=current.next;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            current=pervious.next;
                                            pervious.next=current.next;
                                        }
                                        this.count--;
                                        return current.element;
                                    }
                                    return undefined;
                                }

                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count;
                                }

                                getHead(){
                                    return this.head;
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return  "";
                                    }
                                    let str=`${this.head.element}`;
                                    let current=this.head.next;
                                    for(let i=1; i < this.count && current; i++){
                                        str=`${str},${current.element}`;
                                        current=current.next;
                                    }
                                    return str;
                                }
                            }

                            class CircularLinkedList extends LinkedList{
                                constructor(equalsFn = defaultEquals){
                                    super(equalsFn);
                                }

                                push(element){
                                    let node = new Node(element);
                                    if(!this.head){
                                        this.head=node;
                                        node.next=this.head;
                                    }else{
                                        let current = this.getElementAt(this.count - 1);
                                        current.next=node;
                                        node.next=this.head;
                                    }
                                    this.count++;
                                    
                                }
                                
                                insert(element,index){
                                    if(index >= 0 && index <= this.count){
                                        const node = new Node(element);
                                        if(index===0){
                                            if(this.head==null){
                                                this.head=node;
                                                node.next=this.head;
                                            }else{
                                                let last=this.getElementAt(this.count - 1);
                                                last.next=node;
                                                node.next=this.head;
                                                this.head=node;
                                            }
                                        }else{
                                            const previous = this.getElementAt(index - 1);
                                            node.next=previous.next;
                                            previous.next=node;
                                        }
                                        this.count++;
                                        return true;
                                    }
                                    return false;
                                }

                                removeAt(index){
                                    if(index >= 0 && index < this.count){
                                        let current=this.head;
                                        if(index===0){
                                            if(this.count === 1){
                                                this.head=undefined;
                                            }else{
                                                const remove = this.head;
                                                const last = this.getElementAt(this.count - 1);
                                                this.head=this.head.next;
                                                last.next=this.head;
                                                current = remove;
                                            }
                                        }else{
                                            let pervious=this.getElementAt(index - 1);
                                            current=pervious.next;
                                            pervious.next=current.next;
                                        }
                                        this.count--;
                                        return current;
                                    }
                                    return undefined;
                                }
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>有序链表：</p>
                    <p>
                        <code>
                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }

                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            function defaultEquals(a,b){
                                return a===b;
                            }

                            class Node{
                                constructor(element,next){
                                    this.element=element;
                                    this.next=next;
                                }
                            }

                            class LinkedList{
                                constructor(equalsFn=defaultEquals){
                                    this.count=0;
                                    this.head=undefined;
                                    this.equalsFn=equalsFn;
                                }

                                push(element){
                                    const node = new Node(element);
                                    if(!this.head){
                                        this.head=node;
                                    }else{
                                        let current=this.head;
                                        while(current.next){
                                            current=current.next;
                                        }
                                        current.next=node;
                                    }
                                    this.count++;
                                }
                                
                                insert(element,index){
                                    if(index >= 0 && index <= this.count){
                                        const node = new Node(element);
                                        if(index===0){
                                            node.next=this.head;
                                            this.head=node;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            const current=pervious.next;
                                            node.next=current;
                                            pervious.next=node;
                                        }
                                        this.count++;
                                        return true;
                                    }
                                    return false;
                                }

                                getElementAt(index){
                                    if(index >= 0 && index < this.count){
                                        let node=this.head;
                                        for(let i=0; i < index && node; i++){
                                            node=node.next;
                                        }
                                        return node;
                                    }
                                    return undefined;
                                }

                                remove(element){
                                    const index=this.indexOf(element);
                                    return this.removeAt(index);
                                }

                                indexOf(element){
                                    let current=this.head;
                                    for(let i=0; i < this.count && current; i++){
                                        if(this.equalsFn(current.element,element)){
                                            return i;
                                        }
                                        current=current.next;
                                    }
                                    return -1;
                                }

                                removeAt(index){
                                    if(index >= 0 && index < this.count){
                                        let current=this.head;
                                        if(index===0){
                                            this.head=current.next;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            current=pervious.next;
                                            pervious.next=current.next;
                                        }
                                        this.count--;
                                        return current.element;
                                    }
                                    return undefined;
                                }

                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count;
                                }

                                getHead(){
                                    return this.head;
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return  "";
                                    }
                                    let str=`${this.head.element}`;
                                    let current=this.head.next;
                                    for(let i=1; i < this.count && current; i++){
                                        str=`${str},${current.element}`;
                                        current=current.next;
                                    }
                                    return str;
                                }
                            }

                            class SortedLinkedList extends LinkedList{
                                constructor(equalsFn = defaultEquals, compareFn = defaultCompare){
                                    super(equalsFn);
                                    this.compareFn=compareFn;
                                }

                                insert(element,index=0){
                                    if(this.isEmpty()){
                                        return super.insert(element,0);
                                    }
                                    let pos = this.getIndexNextSortedElement(element);
                                    return super.insert(element, pos);
                                }

                                getIndexNextSortedElement(element){
                                    let current=this.head;
                                    let i =0;
                                    for(;this.size() && current;i++){
                                        const comp = this.compareFn(element,current.element);
                                        if(comp===Compare.LESS_THAN){
                                            return i;
                                        }
                                        current= current.next;
                                    }
                                    return i;
                                }
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>创建StackLinkedList类：</p>
                    <p>
                        <code>
                            function defaultEquals(a,b){
                                return a===b;
                            }

                            class Node{
                                constructor(element,next){
                                    this.element=element;
                                    this.next=next;
                                }
                            }

                            class LinkedList{
                                constructor(equalsFn=defaultEquals){
                                    this.count=0;
                                    this.head=undefined;
                                    this.equalsFn=equalsFn;
                                }

                                push(element){
                                    const node = new Node(element);
                                    if(!this.head){
                                        this.head=node;
                                    }else{
                                        let current=this.head;
                                        while(current.next){
                                            current=current.next;
                                        }
                                        current.next=node;
                                    }
                                    this.count++;
                                }
                                
                                insert(element,index){
                                    if(index >= 0 && index <= this.count){
                                        const node = new Node(element);
                                        if(index===0){
                                            node.next=this.head;
                                            this.head=node;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            const current=pervious.next;
                                            node.next=current;
                                            pervious.next=node;
                                        }
                                        this.count++;
                                        return true;
                                    }
                                    return false;
                                }

                                getElementAt(index){
                                    if(index >= 0 && index < this.count){
                                        let node=this.head;
                                        for(let i=0; i < index && node; i++){
                                            node=node.next;
                                        }
                                        return node;
                                    }
                                    return undefined;
                                }

                                remove(element){
                                    const index=this.indexOf(element);
                                    return this.removeAt(index);
                                }

                                indexOf(element){
                                    let current=this.head;
                                    for(let i=0; i < this.count && current; i++){
                                        if(this.equalsFn(current.element,element)){
                                            return i;
                                        }
                                        current=current.next;
                                    }
                                    return -1;
                                }

                                removeAt(index){
                                    if(index >= 0 && index < this.count){
                                        let current=this.head;
                                        if(index===0){
                                            this.head=current.next;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            current=pervious.next;
                                            pervious.next=current.next;
                                        }
                                        this.count--;
                                        return current.element;
                                    }
                                    return undefined;
                                }

                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count;
                                }

                                getHead(){
                                    return this.head;
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return  "";
                                    }
                                    let str=`${this.head.element}`;
                                    let current=this.head.next;
                                    for(let i=1; i < this.count && current; i++){
                                        str=`${str},${current.element}`;
                                        current=current.next;
                                    }
                                    return str;
                                }
                            }  

                            class DoublyNode extends Node{
                                constructor(element,next,prev){
                                    super(element,next);
                                    this.prev=prev;
                                }
                            }

                            class DoublyLinkedList extends LinkedList{
                                constructor(equalsFn=defaultEquals){
                                    super(equalsFn);
                                    this.tail=undefined;
                                }

                                push(element){
                                    const node = new DoublyNode(element);
                                    if(!this.tail){
                                        this.head=node;
                                        this.tail=node;
                                    }else{
                                        let current=this.tail;
                                        current.next=node;
                                        node.prev=current;
                                        this.tail=node;
                                    }
                                    this.count++;
                                }

                                insert(element,index){
                                    if(index >= 0 && index <= this.count){
                                        const node = new DoublyNode(element);
                                        let current = this.head;
                                        if(index===0){
                                            if(!this.head){
                                                this.head=node;
                                                this.tail=node;
                                            }else{
                                                node.next=this.head;
                                                current.prev=node;
                                                this.head=node;
                                            }
                                        } else if (index===this.count){
                                            current=this.tail;
                                            current.next=node;
                                            node.prev=current;
                                            this.tail=node;
                                        }else{
                                            const previous = this.getElementAt(index-1);
                                            current=previous.next;
                                            previous.next=node;
                                            node.prev=previous;
                                            node.next=currnet;
                                            current.prev=node;
                                        }
                                        this.count++;
                                        return true;
                                    }
                                    return false;
                                }

                                removeAt(index){
                                    if(index >=0 && index < this.count){
                                        let current=this.head;
                                        if(index===0){
                                            this.head=this.head.next;
                                            if(this.count===1){
                                                this.tail=undefined;
                                            }else{
                                                this.head.prev=undefined;
                                            }
                                        }else if (index === this.count - 1){
                                            current=this.tail;
                                            this.tail=current.prev;
                                            this.tail.next=undefined;
                                        }else{
                                            current = this.getElementAt(index);
                                            let previous= current.prev;
                                            previous.next=current.next;
                                            current.next.prev=previous;
                                        }
                                        this.count--;
                                        return current.element;
                                    }
                                    return undefined;
                                }
                            }

                            class StackLinkedList {
                                constructor(){
                                    this.items=new DoublyLinkedList();
                                }

                                push(item){
                                    this.items.push(item);
                                }

                                pop(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    return this.items.removeAt(this.items.size() - 1)
                                }

                                peek() {
                                    if (this.isEmpty()) { 
                                        return undefined; 
                                    } 
                                    return this.items.getElementAt(this.size() - 1).element; 
                                } 

                                isEmpty() { 
                                    return this.items.isEmpty(); 
                                }

                                size() { 
                                    return this.items.size(); 
                                } 

                                clear() { 
                                    this.items.clear(); 
                                }

                                toString() { 
                                    return this.items.toString(); 
                                }
                            }
                        </code>
                    </p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第七章：集合</h2>
            <ul>
                <li>
                    <p>创建集合：</p>
                    <p>
                        <code>
                            class Set{
                                constructor(){
                                    this.items={};
                                }

                                add(element){
                                    if(!this.has(element)){
                                        this.items[element]=element;
                                        return true;
                                    }
                                    return false;
                                }

                                delete(element){
                                    if(this.has(element)){
                                        delete this.items[element];
                                        return true;
                                    }
                                    return false;
                                }

                                has(element){
                                    return Object.prototype.hasOwnProperty.call(this.items,element);
                                }

                                clear(){
                                    this.items={};
                                }

                                size(){
                                    return Object.keys(this.items).length;
                                }

                                values(){
                                    return Object.values(this.items);
                                }

                                union(otherSet){
                                    const unionSet= new Set();
                                    this.values().forEach(value=>{
                                        unionSet.add(value);
                                    });
                                    otherSet.values().forEach(value=>{
                                        unionSet.add(value);
                                    });
                                    return unionSet;
                                }

                                intersection(otherSet){
                                    let bigger=this.values();
                                    let small=otherSet.values();

                                    if(bigger.length < small.length){
                                        [bigger,small]=[small,bigger];
                                    }
                                    const intersectionSet= new Set();
                                    small.forEach(value=>{
                                        if(bigger.includes(value)){
                                            intersectionSet.add(value);
                                        }
                                    });
                                    return intersectionSet;
                                }
                                
                                difference(otherSet){
                                    let differenceSet=new Set():
                                    this.values().forEach(value=>{
                                        if(!otherSet.has(value)){
                                            differenceSet.add(value);
                                        }
                                    });
                                    return differenceSet;
                                }

                                isSubsetOf(otherSet){
                                    let isSubset=this.size() <= otherSet.size();
                                    if(isSubset){
                                        for(let value of this.values()){
                                            if(!otherSet.has(value)){
                                                isSubset=false;
                                                break;
                                            }
                                        }
                                    }
                                    return isSubset;
                                }
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>ECMA2015-Set类：</p>
                    <p>
                        目前Set类已经实现了合集、交集、差集、对称差、判断子集、判断超集、判断不相交：<a
                            href="https://developer.mozilla.org/en-US/blog/javascript-set-methods/">相关链接</a>
                    </p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第八章：字典和散列表</h2>
            <ul>
                <li>
                    <p>字典：</p>
                    <p>
                        <code>
                            function defaultToString(item){
                                if(item === null){
                                    return "NULL";
                                }else if (item===undefined){
                                    return "UNDEFINED";
                                }else if (typeof item === "string" || item instanceof String){
                                    return `${item}`;
                                }
                                return item.toString();
                            }

                            class ValuePair{
                                constructor(key,value){
                                    this.key=key;
                                    this.value=value;                                    
                                }

                                toString(){
                                    return `${this.key}: ${this.value}`;
                                }
                            }

                            class Dictionary{
                                constructor(toStrFn = defaultToString){
                                    this.toStrFn=toStrFn;
                                    this.table={};
                                }

                                set(key,value){
                                    if(key!=null && value != null){
                                        const tableKey = this.toStrFn(key);
                                        this.table[tableKey] = new ValuePair(key,value);
                                        return true;
                                    }
                                    return false;
                                }

                                remove(key){
                                    if(this.hasKey(key)){
                                        delete this.table[this.toStrFn(key)];
                                        return true;
                                    }
                                    return false;
                                }

                                hasKey(key){
                                    return this.table[this.toStrFn(key)] != null;
                                }

                                get(key){
                                    const valuePair = this.table[this.toStrFn(key)];
                                    return valuePair == null ? undefined : valuePair.value;
                                }

                                clear(){
                                    this.table={};
                                }

                                size(){
                                    return Object.keys(this.table).length;
                                }

                                isEmpty(){
                                    return this.size() === 0;
                                }

                                keys(){
                                    return Object.keyValues().map(valuePair => valuePair.key);
                                }

                                values(){
                                    return Object.keyValues().map(valuePair => valuePair.value);
                                }

                                keyValues(){
                                    return Object.values(this.table);
                                }

                                forEach(callbackFn){
                                    const valuePairs = this.keyValues();
                                    for(let i=0 ; i < valuePairs.length; i++){
                                       const result = callbackFn(valuePairs[i].key, valuePairs[i].value);
                                       if(result === false){
                                            break;
                                       }
                                    }
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return "";
                                    }
                                    const valuePairs = this.keyValues();
                                    let objString=`${valuePairs[0].toString()}`;
                                    for(let i=1; i < valuePairs.length;i++){
                                        objString = `${objString},${valuePairs[i].toString()}`;
                                    }
                                    return objString;
                                }
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>散列表：</p>
                    <p>
                        <code>
                            function defaultToString(item){
                                if(item === null){
                                    return "NULL";
                                }else if (item===undefined){
                                    return "UNDEFINED";
                                }else if (typeof item === "string" || item instanceof String){
                                    return `${item}`;
                                }
                                return item.toString();
                            }

                            class ValuePair{
                                constructor(key,value){
                                    this.key=key;
                                    this.value=value;                                    
                                }

                                toString(){
                                    return `${this.key}: ${this.value}`;
                                }
                            }

                            class HashTable{
                                constructor(toStrFn = defaultToString){
                                    this.toStrFn=toStrFn;
                                    this.table={};
                                }

                                put(key,value){
                                    if(key != null && value != null){
                                        this.table[this.hashCode(key)]=new ValuePair(key,value);
                                        return true;
                                    }
                                    return false;
                                }

                                remove(key){
                                    const valuePair=this.table[this.hashCode(key)];
                                    if(valuePair != null){
                                        delete this.table[this.hashCode(key)]
                                        return true;
                                    }
                                    return false;
                                }

                                get(key){
                                    const valuePair=this.table[this.hashCode(key)];
                                    return valuePair == null ? undefined : this.table[this.hashCode(key)];
                                }

                                hashCode(key){
                                    return this.loseloseHashCode(key);
                                }

                                loseloseHashCode(key){
                                    if(typeof key === "number"){
                                        return key;
                                    }
                                    const tableKey=this.toStrFn(key);
                                    let hash=0;
                                    for(let i=0 ; i < tableKey.length; i++){
                                        hash += tableKey.charCodeAt(i);
                                    }
                                    return hash % 37;
                                }

                                size(){
                                    return Object.keys(this.table).length;
                                }

                                isEmpty(){
                                    return this.size() === 0;
                                }

                                keys(){
                                    return Object.keyValues().map(valuePair => valuePair.key);
                                }

                                values(){
                                    return Object.keyValues().map(valuePair => valuePair.value);
                                }

                                keyValues(){
                                    return Object.values(this.table);
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return "";
                                    }
                                    const valuePairs = this.keyValues();
                                    let objString=`${valuePairs[0].toString()}`;
                                    for(let i=1; i < valuePairs.length;i++){
                                        objString = `${objString},${valuePairs[i].toString()}`;
                                    }
                                    return objString;
                                }
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>散列解决冲突-分离链接：</p>
                    <p>
                        <code>
                            function defaultEquals(a,b){
                                return a===b;
                            }

                            class Node{
                                constructor(element,next){
                                    this.element=element;
                                    this.next=next;
                                }
                            }

                            class LinkedList{
                                constructor(equalsFn=defaultEquals){
                                    this.count=0;
                                    this.head=undefined;
                                    this.equalsFn=equalsFn;
                                }

                                push(element){
                                    const node = new Node(element);
                                    if(!this.head){
                                        this.head=node;
                                    }else{
                                        let current=this.head;
                                        while(current.next){
                                            current=current.next;
                                        }
                                        current.next=node;
                                    }
                                    this.count++;
                                }
                                
                                insert(element,index){
                                    if(index >= 0 && index <= this.count){
                                        const node = new Node(element);
                                        if(index===0){
                                            node.next=this.head;
                                            this.head=node;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            const current=pervious.next;
                                            node.next=current;
                                            pervious.next=node;
                                        }
                                        this.count++;
                                        return true;
                                    }
                                    return false;
                                }

                                getElementAt(index){
                                    if(index >= 0 && index < this.count){
                                        let node=this.head;
                                        for(let i=0; i < index && node; i++){
                                            node=node.next;
                                        }
                                        return node;
                                    }
                                    return undefined;
                                }

                                remove(element){
                                    const index=this.indexOf(element);
                                    return this.removeAt(index);
                                }

                                indexOf(element){
                                    let current=this.head;
                                    for(let i=0; i < this.count && current; i++){
                                        if(this.equalsFn(current.element,element)){
                                            return i;
                                        }
                                        current=current.next;
                                    }
                                    return -1;
                                }

                                removeAt(index){
                                    if(index >= 0 && index < this.count){
                                        let current=this.head;
                                        if(index===0){
                                            this.head=current.next;
                                        }else{
                                            const pervious=this.getElementAt(index-1);
                                            current=pervious.next;
                                            pervious.next=current.next;
                                        }
                                        this.count--;
                                        return current.element;
                                    }
                                    return undefined;
                                }

                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count;
                                }

                                getHead(){
                                    return this.head;
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return  "";
                                    }
                                    let str=`${this.head.element}`;
                                    let current=this.head.next;
                                    for(let i=1; i < this.count && current; i++){
                                        str=`${str},${current.element}`;
                                        current=current.next;
                                    }
                                    return str;
                                }
                            }

                            function defaultToString(item){
                                if(item === null){
                                    return "NULL";
                                }else if (item===undefined){
                                    return "UNDEFINED";
                                }else if (typeof item === "string" || item instanceof String){
                                    return `${item}`;
                                }
                                return item.toString();
                            }

                            class ValuePair{
                                constructor(key,value){
                                    this.key=key;
                                    this.value=value;                                    
                                }

                                toString(){
                                    return `${this.key}: ${this.value}`;
                                }
                            }

                            class HashTableSeparateChaining{
                                constructor(toStrFn = defaultToString){
                                    this.toStrFn=toStrFn;
                                    this.table={};
                                }

                                put(key,value){
                                    if(key != null && value != null){
                                        const position = this.hashCode(key);
                                        if(this.table[position] == null){
                                            this.table[position]=new LinkedList();
                                        }
                                        this.table[position].push(new ValuePair(key,value));
                                        return true;
                                    }
                                    return false;
                                }

                                get(key){
                                    const position = this.hashCode(key);
                                    const linkedList = this.table[position];
                                    if(linkedList != null && !linkedList.isEmpty()){
                                        let current = linkedList.getHead();
                                        while(current != null){
                                            if(current.element.key === key){
                                                return current.element.value;
                                            }
                                            current=current.next;
                                        }
                                    }
                                    return undefined;
                                }

                                remove(key){
                                    const position = this.hashCode(key);
                                    const linkedList = this.table[position];
                                    if(linkedList != null && !linkedList.isEmpty()){
                                        let current = linkedList.getHead();
                                        while(current != null){
                                            if(current.element.key === key){
                                                linkedList.remove(current.element);
                                                if(linkedList.isEmpty()){
                                                  delete this.table[position];
                                                }
                                                return true;
                                            }
                                            current=current.next;
                                        }
                                    }
                                    return false;
                                }

                                hashCode(key){
                                    return this.loseloseHashCode(key);
                                }

                                loseloseHashCode(key){
                                    if(typeof key === "number"){
                                        return key;
                                    }
                                    const tableKey=this.toStrFn(key);
                                    let hash=0;
                                    for(let i=0 ; i < tableKey.length; i++){
                                        hash += tableKey.charCodeAt(i);
                                    }
                                    return hash % 37;
                                }
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>散列解决冲突-线性探查</p>
                    <p>
                        <code>
                            function defaultToString(item){
                                if(item === null){
                                    return "NULL";
                                }else if (item===undefined){
                                    return "UNDEFINED";
                                }else if (typeof item === "string" || item instanceof String){
                                    return `${item}`;
                                }
                                return item.toString();
                            }

                            class ValuePair{
                                constructor(key,value){
                                    this.key=key;
                                    this.value=value;                                    
                                }

                                toString(){
                                    return `${this.key}: ${this.value}`;
                                }
                            }

                            class HashTableLinearProbing{
                                constructor(toStrFn = defaultToString){
                                    this.toStrFn=toStrFn;
                                    this.table={};
                                }

                                put(key,value){
                                    if(key != null && value != null){
                                        let position= this.hashCode(key);
                                        if(this.table[position] == null){
                                            this.table[position] = new ValuePair(key,value);
                                        }else{
                                            let index = position+1;
                                            while(this.table[index] != null){
                                                index++;
                                            }
                                            this.table[index] = new ValuePair(key,value);
                                        }
                                        return true;
                                    }
                                    return false;
                                }

                                hashCode(key){
                                    return this.loseloseHashCode(key);
                                }

                                loseloseHashCode(key){
                                    if(typeof key === "number"){
                                        return key;
                                    }
                                    const tableKey=this.toStrFn(key);
                                    let hash=0;
                                    for(let i=0 ; i < tableKey.length; i++){
                                        hash += tableKey.charCodeAt(i);
                                    }
                                    return hash % 37;
                                }

                                get(key){
                                    let position = this.hashCode(key);
                                    if (this.table[position] != null) {
                                        if(this.table[position].key === key){
                                            return this.table[position].value;
                                        }
                                        let index = position + 1;
                                        while (this.table[index] != null && this.table[index].key !== key) { 
                                            index++; 
                                        } 
                                        if (this.table[index] != null && this.table[index].key === key) { 
                                            return this.table[index].value;
                                        }
                                    }
                                    return undefined;
                                }

                                remove(key){
                                    let position = this.hashCode(key);
                                    if(this.table[position] != null){
                                        if(this.table[position].key === key){
                                            delete this.table[position];
                                            this.verifyRemoveSideEffect(key, position);
                                            return true;
                                        }
                                        let index = position + 1;
                                        while (this.table[index] != null && this.table[index].key !== key) { 
                                            index++; 
                                        } 
                                        if (this.table[index] != null && this.table[index].key === key) { 
                                            delete this.table[index];
                                            this.verifyRemoveSideEffect(key, index);
                                            return true;
                                        }
                                    }
                                    return false;
                                }

                                verifyRemoveSideEffect(key, removedPosition) { 
                                    const hash = this.hashCode(key); 
                                    let index = removedPosition + 1; 
                                    while (this.table[index] != null) { 
                                        const posHash = this.hashCode(this.table[index].key);
                                        if (posHash <= hash || posHash <= removedPosition) { 
                                            this.table[removedPosition] = this.table[index];
                                            delete this.table[index]; 
                                            removedPosition = index; 
                                        } 
                                        index++; 
                                    } 
                                }
                            }
                           
                        </code>
                    </p>
                </li>
                <li>
                    <p>更好的散列函数：</p>
                    <p>
                        <code>
                            function defaultToString(item){
                                if(item === null){
                                    return "NULL";
                                }else if (item===undefined){
                                    return "UNDEFINED";
                                }else if (typeof item === "string" || item instanceof String){
                                    return `${item}`;
                                }
                                return item.toString();
                            }

                            function djb2HashCode(key){
                                const tableKey = defaultToString(key); 
                                let hash = 5381; 
                                for (let i = 0; i < tableKey.length; i++) { 
                                    hash = (hash * 33) + tableKey.charCodeAt(i);
                                } 
                                return hash % 1013; 
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>ECMA2015 Map：</p>
                    <p>
                        <code>
                        const map = new Map();
                        map.set("v1",1);
                        map.get("v1");
                        console.log(map.has("v1"));
                        console.log(map.size);
                       </code>
                    </p>
                </li>
                <li>
                    <p>ECMA2015 WeakMap、WeakSet：</p>
                    <p>WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法；只能用对象作为键。创建和使用这两个类主要是为了性能。WeakSet 和 WeakMap
                        是弱化的（用对象作为键），没有强引用的键。这使得 JavaScript 的垃圾回收器可以从中清除整个入口。</p>

                </li>
            </ul>
        </section>
        <section>
            <h2>第九章：递归</h2>
            <ul>
                <li>
                    <p>阶乘：</p>
                    <p>
                        <code>
                            function recursiveFn(num){
                                if(num<=1){
                                    return 1;
                                }
                                return num * recursiveFn(num-1);
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>斐波那契数列：</p>
                    <p>
                        <code>
                            function fibonacciIterative(n){
                                if(n < 1){
                                    return 0
                                }
                                if(n <= 2){
                                    return 1;
                                }
                                return fibonacciIterative(n - 1) + fibonacciIterative(n - 2);
                            }
                        </code>
                    </p>
                </li>

            </ul>
        </section>
        <section>
            <h2>第十章：树</h2>
            <ul>
                <li>
                    <p>二叉树和二叉搜索树：</p>
                    <p>
                        <code>
                            class Node {
                                constructor(key){
                                    this.key=key;
                                    this.left=null;
                                    this.right=null;
                                }
                            }

                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            class BinarySearchTree{
                                constructor(compareFn = defaultCompare){
                                    this.compareFn = compareFn;
                                    this.root = null;
                                }

                                insert(key){
                                    if(!this.root){
                                        this.root =  new Node(key)
                                    }else{
                                        this.insertNode(this.root,key);
                                    }
                                }

                                insertNode(node,key){
                                    if(this.compareFn(key,node.key) === Compare.LESS_THAN){
                                        if(node.left === null){
                                            node.left= new Node(key);
                                        }else{
                                            this.insertNode(node.left,key);
                                        }
                                    }else{
                                        if(node.right === null){
                                            node.right= new Node(key);
                                        }else{
                                            this.insertNode(node.right,key);
                                        }
                                    }
                                }

                                search(key){
                                    return this.searchNode(this.root,key);
                                }

                                searchNode(node,key){
                                    if(node == null){
                                        return false;
                                    }
                                    if((this.compareFn(key, node.key) === Compare.LESS_THAN)){
                                        return this.searchNode(node.left,key);
                                    }else if (key > node.key){
                                        return this.searchNode(node.right,key);
                                    }else{
                                        return true;
                                    }
                                }

                                
                                inOrderTraverse(callBack){
                                    this.inOrderTraverseNode(this.root,callBack);
                                }

                                inOrderTraverseNode(node,callBack){
                                    if(node != null){
                                        this.inOrderTraverseNode(node.left, callBack);
                                        callBack(node.key);
                                        this.inOrderTraverseNode(node.right, callBack);
                                    }

                                }

                                preOrderTraverse(callBack){
                                    this.preOrderTraverseNode(this.root, callBack);
                                }

                                preOrderTraverseNode(node, callBack){
                                    if(node != null){
                                        callBack(node.key);
                                        this.preOrderTraverseNode(node.left);
                                        this.preOrderTraverseNode(node.right);
                                    }
                                }

                                postOrderTraverse(callBack){
                                    this.postOrderTraverseNode(this.root,callBack)
                                }
                                
                                postOrderTraverseNode(node, callBack){
                                    if(node != null){
                                        this.postOrderTraverseNode(node.left,callBack);
                                        this.postOrderTraverseNode(node.right,callBack);
                                        callBack(node.key);
                                    }
                                }

                                min(){
                                    return this.minNode(this.root);
                                }

                                minNode(node){
                                    if(node.left){
                                        return this.minNode(node.left);
                                    }else{
                                        return node.key;
                                    }
                                }

                                max(){
                                    return this.maxNode(this.root);
                                }
                                
                                maxNode(node){
                                    let current=node;
                                    while(current != null && current.right != null){
                                        current=current.right;
                                    }
                                    return current.key;
                                }

                                remove(){
                                    return this.removeNode(this.root,key);
                                }

                                removeNode(node, key){
                                    if(node == null){
                                        return null;
                                    }
                                    if(this.compareFn(key, node.key) === Compare.LESS_THAN){
                                        node.left = this.removeNode(node.left, key);
                                        return node;
                                    }else if(this.compareFn(key, node.key) === Compare.BIGGER_THAN){
                                        node.right = this.removeNode(node.left, key);
                                        return node;
                                    }else{
                                        if(node.left == null && node.right == null){
                                            node=null;
                                            return node;
                                        }

                                        if(node.left == null){
                                            node = node.right;
                                            return node;
                                        }else if (node.right == null){
                                            node = node.left;
                                            return node;
                                        }

                                        const aux = this.minNode(node.right);
                                        node.key = aux.key;
                                        node.right = this.removeNode(node.right, aux.key);
                                        return node;

                                    }
                                }

                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>自平衡树：</p>
                    <p>
                        <code>
                            class Node {
                                constructor(key){
                                    this.key=key;
                                    this.left=null;
                                    this.right=null;
                                }
                            }

                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            class BinarySearchTree{
                                constructor(compareFn = defaultCompare){
                                    this.compareFn = compareFn;
                                    this.root = null;
                                }

                                insert(key){
                                    if(!this.root){
                                        this.root =  new Node(key)
                                    }else{
                                        this.insertNode(this.root,key);
                                    }
                                }

                                insertNode(node,key){
                                    if(this.compareFn(key,node.key) === Compare.LESS_THAN){
                                        if(node.left === null){
                                            node.left= new Node(key);
                                        }else{
                                            this.insertNode(node.left,key);
                                        }
                                    }else{
                                        if(node.right === null){
                                            node.right= new Node(key);
                                        }else{
                                            this.insertNode(node.right,key);
                                        }
                                    }
                                }

                                search(key){
                                    return this.searchNode(this.root,key);
                                }

                                searchNode(node,key){
                                    if(node == null){
                                        return false;
                                    }
                                    if((this.compareFn(key, node.key) === Compare.LESS_THAN)){
                                        return this.searchNode(node.left,key);
                                    }else if (key > node.key){
                                        return this.searchNode(node.right,key);
                                    }else{
                                        return true;
                                    }
                                }

                                
                                inOrderTraverse(callBack){
                                    this.inOrderTraverseNode(this.root,callBack);
                                }

                                inOrderTraverseNode(node,callBack){
                                    if(node != null){
                                        this.inOrderTraverseNode(node.left, callBack);
                                        callBack(node.key);
                                        this.inOrderTraverseNode(node.right, callBack);
                                    }

                                }

                                preOrderTraverse(callBack){
                                    this.preOrderTraverseNode(this.root, callBack);
                                }

                                preOrderTraverseNode(node, callBack){
                                    if(node != null){
                                        callBack(node.key);
                                        this.preOrderTraverseNode(node.left);
                                        this.preOrderTraverseNode(node.right);
                                    }
                                }

                                postOrderTraverse(callBack){
                                    this.postOrderTraverseNode(this.root,callBack)
                                }
                                
                                postOrderTraverseNode(node, callBack){
                                    if(node != null){
                                        this.postOrderTraverseNode(node.left,callBack);
                                        this.postOrderTraverseNode(node.right,callBack);
                                        callBack(node.key);
                                    }
                                }

                                min(){
                                    return this.minNode(this.root);
                                }

                                minNode(node){
                                    if(node.left){
                                        return this.minNode(node.left);
                                    }else{
                                        return node.key;
                                    }
                                }

                                max(){
                                    return this.maxNode(this.root);
                                }
                                
                                maxNode(node){
                                    let current=node;
                                    while(current != null && current.right != null){
                                        current=current.right;
                                    }
                                    return current.key;
                                }

                                remove(){
                                    return this.removeNode(this.root,key);
                                }

                                removeNode(node, key){
                                    if(node == null){
                                        return null;
                                    }
                                    if(this.compareFn(key, node.key) === Compare.LESS_THAN){
                                        node.left = this.removeNode(node.left, key);
                                        return node;
                                    }else if(this.compareFn(key, node.key) === Compare.BIGGER_THAN){
                                        node.right = this.removeNode(node.left, key);
                                        return node;
                                    }else{
                                        if(node.left == null && node.right == null){
                                            node=null;
                                            return node;
                                        }

                                        if(node.left == null){
                                            node = node.right;
                                            return node;
                                        }else if (node.right == null){
                                            node = node.left;
                                            return node;
                                        }

                                        const aux = this.minNode(node.right);
                                        node.key = aux.key;
                                        node.right = this.removeNode(node.right, aux.key);
                                        return node;

                                    }
                                }

                            }

                            const BalanceFactor = {
                                UNBALANCED_RIGHT: 1, 
                                SLIGHTLY_UNBALANCED_RIGHT: 2, 
                                BALANCED: 3, 
                                SLIGHTLY_UNBALANCED_LEFT: 4, 
                                UNBALANCED_LEFT: 5
                            };

                            class AVLTree extends BinarySearchTree { 
                                constructor(compareFn = defaultCompare) { 
                                    super(compareFn); 
                                }

                                insert(key){
                                    this.root =  this.insertNode(this.root,key);
                                }

                                insertNode(node,key){
                                    if(node == null){
                                        return new Node(key);
                                    }else if(this.compareFn(key, node.key) ===  Compare.LESS_THAN){
                                        node.left = this.insertNode(node.left,key);
                                    }else if(this.compareFn(key, node.key) ===  Compare.BIGGER_THAN){
                                        node.right=this.insertNode(node.right,key);
                                    }else{
                                        return node;
                                    }

                                    const balanceFactor = this.getBalanceFactor(node);
                                    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {
                                        if (this.compareFn(key, node.left.key) === Compare.LESS_THAN) {
                                            node = this.rotationLL(node);
                                        } else {
                                            return this.rotationLR(node);
                                        } 
                                    } 
                                    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {
                                        if (this.compareFn(key, node.right.key) === Compare.BIGGER_THAN ) {
                                            node = this.rotationRR(node);
                                        } else {
                                            return this.rotationRL(node);
                                        } 
                                    } 
                                    return node;
                                }

                                removeNode(node,key){
                                    node = supert.removeNode(node,key);
                                    if(node == null){
                                        return node;
                                    }

                                    const balanceFactor = this.getBalanceFactor(node);
                                    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {
                                        const balanceFactorLeft = this.getBalanceFactor(node.left);
                                        if (balanceFactorLeft === BalanceFactor.BALANCED || balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) { 
                                            return this.rotationLL(node);
                                        } 
                                        if (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {
                                            return this.rotationLR(node.left);
                                        } 
                                    } 
                                    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {
                                        const balanceFactorRight = this.getBalanceFactor(node.right);
                                        if (balanceFactorRight === BalanceFactor.BALANCED || balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {
                                            return this.rotationRR(node);
                                        } 
                                        if (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {
                                            return this.rotationRL(node.right);
                                        } 
                                    } 
                                    return node;
                                }

                                getNodeHeight(node){
                                    if(node==null){
                                        return -1;
                                    }

                                    return Math.max(this.getNodeHeight(node.left),this.getNodeHeight(node.right)) + 1;
                                }

                                getBalanceFactor(node){
                                    const heightDifference = this.getNodeHeight(node.left) - this.getNodeHeight(node.right);
                                    switch(heightDifference){
                                        case -2: 
                                            return BalanceFactor.UNBALANCED_RIGHT; 
                                        case -1: 
                                            return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT; 
                                        case 1: 
                                            return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT; 
                                        case 2: 
                                            return BalanceFactor.UNBALANCED_LEFT; 
                                        default: 
                                            return BalanceFactor.BALANCED;
                                    }
                                }

                                rotationLL(node){
                                    let tmp = node.left;
                                    node.left = tmp.right;
                                    tmp.right=node;
                                    return tmp;
                                }

                                rotationRR(node){
                                    let tmp = node.right;
                                    node.right=tmp.left;
                                    tmp.left=node;
                                    return tmp;
                                }

                                rotationLR(node){
                                    node.left = this.rotationRR(node.left)
                                    return this.rotationLL(node);
                                }

                                rotationRL(node){
                                    node.right = this.rotationLL(node.right);
                                    return this.rotationRR(node);
                                }
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>红黑树：</p>
                    <p>
                        <code>
                            class Node {
                                constructor(key){
                                    this.key=key;
                                    this.left=null;
                                    this.right=null;
                                }
                            }

                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            class BinarySearchTree{
                                constructor(compareFn = defaultCompare){
                                    this.compareFn = compareFn;
                                    this.root = null;
                                }

                                insert(key){
                                    if(!this.root){
                                        this.root =  new Node(key)
                                    }else{
                                        this.insertNode(this.root,key);
                                    }
                                }

                                insertNode(node,key){
                                    if(this.compareFn(key,node.key) === Compare.LESS_THAN){
                                        if(node.left === null){
                                            node.left= new Node(key);
                                        }else{
                                            this.insertNode(node.left,key);
                                        }
                                    }else{
                                        if(node.right === null){
                                            node.right= new Node(key);
                                        }else{
                                            this.insertNode(node.right,key);
                                        }
                                    }
                                }

                                search(key){
                                    return this.searchNode(this.root,key);
                                }

                                searchNode(node,key){
                                    if(node == null){
                                        return false;
                                    }
                                    if((this.compareFn(key, node.key) === Compare.LESS_THAN)){
                                        return this.searchNode(node.left,key);
                                    }else if (key > node.key){
                                        return this.searchNode(node.right,key);
                                    }else{
                                        return true;
                                    }
                                }

                                
                                inOrderTraverse(callBack){
                                    this.inOrderTraverseNode(this.root,callBack);
                                }

                                inOrderTraverseNode(node,callBack){
                                    if(node != null){
                                        this.inOrderTraverseNode(node.left, callBack);
                                        callBack(node.key);
                                        this.inOrderTraverseNode(node.right, callBack);
                                    }

                                }

                                preOrderTraverse(callBack){
                                    this.preOrderTraverseNode(this.root, callBack);
                                }

                                preOrderTraverseNode(node, callBack){
                                    if(node != null){
                                        callBack(node.key);
                                        this.preOrderTraverseNode(node.left);
                                        this.preOrderTraverseNode(node.right);
                                    }
                                }

                                postOrderTraverse(callBack){
                                    this.postOrderTraverseNode(this.root,callBack)
                                }
                                
                                postOrderTraverseNode(node, callBack){
                                    if(node != null){
                                        this.postOrderTraverseNode(node.left,callBack);
                                        this.postOrderTraverseNode(node.right,callBack);
                                        callBack(node.key);
                                    }
                                }

                                min(){
                                    return this.minNode(this.root);
                                }

                                minNode(node){
                                    if(node.left){
                                        return this.minNode(node.left);
                                    }else{
                                        return node.key;
                                    }
                                }

                                max(){
                                    return this.maxNode(this.root);
                                }
                                
                                maxNode(node){
                                    let current=node;
                                    while(current != null && current.right != null){
                                        current=current.right;
                                    }
                                    return current.key;
                                }

                                remove(){
                                    return this.removeNode(this.root,key);
                                }

                                removeNode(node, key){
                                    if(node == null){
                                        return null;
                                    }
                                    if(this.compareFn(key, node.key) === Compare.LESS_THAN){
                                        node.left = this.removeNode(node.left, key);
                                        return node;
                                    }else if(this.compareFn(key, node.key) === Compare.BIGGER_THAN){
                                        node.right = this.removeNode(node.left, key);
                                        return node;
                                    }else{
                                        if(node.left == null && node.right == null){
                                            node=null;
                                            return node;
                                        }

                                        if(node.left == null){
                                            node = node.right;
                                            return node;
                                        }else if (node.right == null){
                                            node = node.left;
                                            return node;
                                        }

                                        const aux = this.minNode(node.right);
                                        node.key = aux.key;
                                        node.right = this.removeNode(node.right, aux.key);
                                        return node;

                                    }
                                }

                            }
                            
                            const Colors={
                                RED:1,
                                BLACK:2
                            }
                            
                            class RedBlackNode extends Node{
                                constructor(key){
                                    super(key);
                                    this.color=Colors.RED;
                                    this.parent = null;
                                }

                                isRed(){
                                    return this.color === Colors.red;
                                }
                            }

                            class RedBlackTree extends BinarySearchTree {
                                constructor(compareFn = defaultCompare){
                                    super(compareFn);
                                }

                                insert(key){
                                    if(this.root == null){
                                        this.root= new RedBlackNode(key);
                                        root.color=Colors.BLACK;
                                    }else{
                                        const newNode = this.insertNode(this.root, key);
                                        this.fixTreeProperties(newNode);
                                    }
                                }

                                insertNode(node,key){
                                    if(this.compareFn(key,node.key) === Compare.LESS_THAN){
                                        if(node.left == null){
                                            node.left = new  RedBlackNode(key);
                                            node.left.parent = node;
                                            return node.left;
                                        }else{
                                            return this.insertNode(node.left,key);
                                        }
                                    }else{
                                        if(node.right == null){
                                            node.right = new RedBlackNode(key);
                                            node.right.parent = node;
                                            return node;
                                        }else{
                                            return this.insertNode(node.right,key);
                                        }
                                    }
                                }

                                fixTreeProperties(node){
                                    while(node && node.parent && node.parent.color.isRed() && node.color != Colors.BLACK){
                                        let parent = node.parent;
                                        const grandParent = parent.parent;
                                        if(grandParent && grandParent.left === parent){
                                            const uncle = grandParent.right;
                                            if(uncle && uncle.color === Colors.RED){
                                                grandParent.color=Colors.RED;
                                                parent.color = Colors.BLACK;
                                                uncle.color=Colors.BLACK;
                                                node=grandParent;
                                            }else{
                                                if (node === parent.right) { 
                                                    this.rotationRR(parent); 
                                                    node = parent;
                                                    parent = node.parent;
                                                }else{
                                                    this.rotationLL(grandParent);
                                                    parent.color = Colors.BLACK;
                                                    grandParent.color = Colors.RED;
                                                    node = parent;
                                                }
                                                
                                            }
                                        }else{
                                            const uncle = grandParent.left;
                                            if(uncle && uncle.color === Colors.RED){
                                                grandParent.color=Colors.RED;
                                                parent.color = Colors.BLACK;
                                                uncle.color=Colors.BLACK;
                                                node=grandParent;
                                            }else{
                                                if (node === parent.left) { 
                                                    this.rotationLL(parent);
                                                    node = parent; 
                                                    parent = node.parent; 
                                                }else{
                                                    this.rotationRR(grandParent);
                                                    parent.color = Colors.BLACK; 
                                                    grandParent.color = Colors.RED; 
                                                    node = parent;
                                                }
                                            }
                                        }
                                    }
                                    this.root.color = Colors.BLACK;
                                }

                                rotationLL(node){
                                    const tmp = node.left;
                                    node.left = tmp.right;
                                    if (tmp.right && tmp.right.key) { 
                                        tmp.right.parent = node;
                                    } 
                                    tmp.parent = node.parent; 
                                    if (!node.parent) { 
                                        this.root = tmp; 
                                    } else { 
                                        if (node === node.parent.left) { 
                                            node.parent.left = tmp;
                                        } else { 
                                            node.parent.right = tmp;
                                        } 
                                    } 
                                    tmp.right = node; 
                                    node.parent = tmp;
                                }

                                rotationRR(node) { 
                                    const tmp = node.right; 
                                    node.right = tmp.left; 
                                    if (tmp.left && tmp.left.key) { 
                                        tmp.left.parent = node;
                                    } 
                                    tmp.parent = node.parent; 
                                    if (!node.parent) { 
                                        this.root = tmp; 
                                    } else { 
                                        if (node === node.parent.left) { 
                                            node.parent.left = tmp;
                                        } else { 
                                            node.parent.right = tmp;
                                        } 
                                    } 
                                    tmp.left = node; 
                                    node.parent = tmp; 
                                }
                            }
                        </code>
                    </p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第十一章：二叉堆和堆排序</h2>
            <ul>
                <li>
                    <p>二叉堆-最小堆、最大堆：</p>
                    <p>
                        <code>
                            class Node {
                                constructor(key){
                                    this.key=key;
                                    this.left=null;
                                    this.right=null;
                                }
                            }

                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            function swap(array, a, b) { 
                                const temp = array[a];
                                array[a] = array[b];
                                array[b] = temp;
                            }
                            
                            class MinHeap{
                                constructor(compareFn = defaultCompare){
                                    this.compareFn = compareFn;
                                    this.heap = [];
                                }

                                insert(value){
                                    if(value != null){
                                        this.heap.push(value);
                                        this.siftUp(this.heap.length - 1);
                                        return true;
                                    }
                                    return false;
                                }

                                siftUp(index){
                                    let parent = this.getParentIndex(index);

                                    while(index > 0 && this.compareFn(this.heap[parent],this.heap[index]) === Compare.BIGGER_THAN ){
                                        swap(this.heap, index, parent);
                                        index = parent;
                                        parent = this.getParentIndex(index);
                                    }
                                }

                                extract(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    if(this.size()===1){
                                        return this.heap.shift();
                                    }
                                    const removedValue = this.heap.shift();
                                    this.heap.unshift(this.heap.pop());
                                    this.siftDown(0);
                                    return removedValue;
                                }

                                siftDown(index){
                                    let element = index;
                                    const left = this.getLeftIndex(index);
                                    const right = this.getRightIndex(index);
                                    const size = this.size();
                                    if(left < size && this.compareFn(this.heap[element],this.heap[left]) === Compare.BIGGER_THAN){
                                        element = left;
                                    }
                                    if(right < size && this.compareFn(this.heap[element],this.heap[right]) === Compare.BIGGER_THAN){
                                        element = right;
                                    }

                                    if(index != element){
                                        swap(this.heap, element, index);
                                        this.siftDown(element);
                                    }
                                }

                                findMinimum(){
                                    return this.isEmpty() ? undefined : this.heap[0];
                                }

                                getLeftIndex(index){
                                    return 2 * index + 1;
                                }

                                getRightIndex(index){
                                    return 2 * index + 2;
                                }

                                getParentIndex(index){
                                    if(index === 0) {
                                        return undefined;
                                    }
                                    return Math.floor((index-1)/2);
                                }

                                size(){
                                    return this.heap.length;
                                }

                                isEmpty(){
                                    return this.size() === 0;
                                }
                                
                            }

                            function reverseCompare(compareFn) { 
                                return (a, b) => compareFn(b, a); 
                            }

                            class MaxHeap extends MinHeap { 
                                constructor(compareFn = defaultCompare) { 
                                    super(compareFn); 
                                    this.compareFn = reverseCompare(compareFn);
                                }
                            }

                            
                        </code>
                    </p>
                </li>
                <li>
                    <p>堆排序算法：</p>
                    <p>
                        我们可以使用二叉堆数据结构来帮助我们创建一个非常著名的排序算法：堆排序算法。它包含下面三个步骤 <br />
                        (1) 用数组创建一个最大堆用作源数据。<br />
                        (2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。<br />
                        (3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1。我们用最大堆得到一个升序排列的数组（从最小到最大）。如果我们想要这个数组按降序排列，可以用最小堆代替。<br />
                        堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。我们会在第 13 章探索更好的排序算法。
                    </p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第十二章：图</h2>
            <ul>
                <li>
                    <p>图：</p>
                    <p>
                        <code>
                            function defaultToString(item){
                                if(item === null){
                                    return "NULL";
                                }else if (item===undefined){
                                    return "UNDEFINED";
                                }else if (typeof item === "string" || item instanceof String){
                                    return `${item}`;
                                }
                                return item.toString();
                            }

                            class ValuePair{
                                constructor(key,value){
                                    this.key=key;
                                    this.value=value;                                    
                                }

                                toString(){
                                    return `${this.key}: ${this.value}`;
                                }
                            }

                            class Dictionary{
                                constructor(toStrFn = defaultToString){
                                    this.toStrFn=toStrFn;
                                    this.table={};
                                }

                                set(key,value){
                                    if(key!=null && value != null){
                                        const tableKey = this.toStrFn(key);
                                        this.table[tableKey] = new ValuePair(key,value);
                                        return true;
                                    }
                                    return false;
                                }

                                remove(key){
                                    if(this.hasKey(key)){
                                        delete this.table[this.toStrFn(key)];
                                        return true;
                                    }
                                    return false;
                                }

                                hasKey(key){
                                    return this.table[this.toStrFn(key)] != null;
                                }

                                get(key){
                                    const valuePair = this.table[this.toStrFn(key)];
                                    return valuePair == null ? undefined : valuePair.value;
                                }

                                clear(){
                                    this.table={};
                                }

                                size(){
                                    return Object.keys(this.table).length;
                                }

                                isEmpty(){
                                    return this.size() === 0;
                                }

                                keys(){
                                    return Object.keyValues().map(valuePair => valuePair.key);
                                }

                                values(){
                                    return Object.keyValues().map(valuePair => valuePair.value);
                                }

                                keyValues(){
                                    return Object.values(this.table);
                                }

                                forEach(callbackFn){
                                    const valuePairs = this.keyValues();
                                    for(let i=0 ; i < valuePairs.length; i++){
                                       const result = callbackFn(valuePairs[i].key, valuePairs[i].value);
                                       if(result === false){
                                            break;
                                       }
                                    }
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return "";
                                    }
                                    const valuePairs = this.keyValues();
                                    let objString=`${valuePairs[0].toString()}`;
                                    for(let i=1; i < valuePairs.length;i++){
                                        objString = `${objString},${valuePairs[i].toString()}`;
                                    }
                                    return objString;
                                }
                            }

                            class Graph {
                                constructor(isDirected = false){
                                    this.isDirected = isDirected;
                                    this.vertices = [];
                                    this.adjList = new Dictionary();
                                }

                                addVertex(v){
                                    if(!this.vertices.includes(v)){
                                        this.vertices.push(v);
                                        this.adjList.set(v,[]);
                                    }
                                }
                                
                                addEdge(v,w){
                                    if(!this.adjList.get(v)){
                                        this.addVertex(v);
                                    }
                                    if(!this.adjList.get(w)){
                                        this.addVertex(w);
                                    }
                                    this.adjList.get(v).push(w);
                                    if(!this.isDirected){
                                        this.adjList.get(w).push(v);
                                    }
                                }

                                getVertices(){
                                    return this.vertices;
                                }

                                getAdjList(){
                                    return this.adjList;
                                }

                                toString(){
                                    let str = "";
                                    for(let i=0; i < this.vertices.length; i++){
                                        str += `${this.vertices[i]} -> `
                                        const neighbors = this.adjList.get(this.vertices[i])
                                        for (let j = 0; j < neighbors.length; j++) {
                                            str += `${neighbors[j]} `; 
                                        } 
                                        str += '\n';
                                    }
                                    return str;
                                }
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>广度优先算法、深度优先算法：</p>
                    <p>
                        <code>
                            function defaultToString(item){
                                if(item === null){
                                    return "NULL";
                                }else if (item===undefined){
                                    return "UNDEFINED";
                                }else if (typeof item === "string" || item instanceof String){
                                    return `${item}`;
                                }
                                return item.toString();
                            }

                            class ValuePair{
                                constructor(key,value){
                                    this.key=key;
                                    this.value=value;                                    
                                }

                                toString(){
                                    return `${this.key}: ${this.value}`;
                                }
                            }

                            class Dictionary{
                                constructor(toStrFn = defaultToString){
                                    this.toStrFn=toStrFn;
                                    this.table={};
                                }

                                set(key,value){
                                    if(key!=null && value != null){
                                        const tableKey = this.toStrFn(key);
                                        this.table[tableKey] = new ValuePair(key,value);
                                        return true;
                                    }
                                    return false;
                                }

                                remove(key){
                                    if(this.hasKey(key)){
                                        delete this.table[this.toStrFn(key)];
                                        return true;
                                    }
                                    return false;
                                }

                                hasKey(key){
                                    return this.table[this.toStrFn(key)] != null;
                                }

                                get(key){
                                    const valuePair = this.table[this.toStrFn(key)];
                                    return valuePair == null ? undefined : valuePair.value;
                                }

                                clear(){
                                    this.table={};
                                }

                                size(){
                                    return Object.keys(this.table).length;
                                }

                                isEmpty(){
                                    return this.size() === 0;
                                }

                                keys(){
                                    return Object.keyValues().map(valuePair => valuePair.key);
                                }

                                values(){
                                    return Object.keyValues().map(valuePair => valuePair.value);
                                }

                                keyValues(){
                                    return Object.values(this.table);
                                }

                                forEach(callbackFn){
                                    const valuePairs = this.keyValues();
                                    for(let i=0 ; i < valuePairs.length; i++){
                                       const result = callbackFn(valuePairs[i].key, valuePairs[i].value);
                                       if(result === false){
                                            break;
                                       }
                                    }
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return "";
                                    }
                                    const valuePairs = this.keyValues();
                                    let objString=`${valuePairs[0].toString()}`;
                                    for(let i=1; i < valuePairs.length;i++){
                                        objString = `${objString},${valuePairs[i].toString()}`;
                                    }
                                    return objString;
                                }
                            }

                            class Graph {
                                constructor(isDirected = false){
                                    this.isDirected = isDirected;
                                    this.vertices = [];
                                    this.adjList = new Dictionary();
                                }

                                addVertex(v){
                                    if(!this.vertices.includes(v)){
                                        this.vertices.push(v);
                                        this.adjList.set(v,[]);
                                    }
                                }
                                
                                addEdge(v,w){
                                    if(!this.adjList.get(v)){
                                        this.addVertex(v);
                                    }
                                    if(!this.adjList.get(w)){
                                        this.addVertex(w);
                                    }
                                    this.adjList.get(v).push(w);
                                    if(!this.isDirected){
                                        this.adjList.get(w).push(v);
                                    }
                                }

                                getVertices(){
                                    return this.vertices;
                                }

                                getAdjList(){
                                    return this.adjList;
                                }

                                toString(){
                                    let str = "";
                                    for(let i=0; i < this.vertices.length; i++){
                                        str += `${this.vertices[i]} -> `
                                        const neighbors = this.adjList.get(this.vertices[i])
                                        for (let j = 0; j < neighbors.length; j++) {
                                            str += `${neighbors[j]} `; 
                                        } 
                                        str += '\n';
                                    }
                                    return str;
                                }
                            }

                            const Colors = { 
                                WHITE: 0, 
                                GREY: 1, 
                                BLACK: 2 
                            };

                            const initializeColor = vertices => { 
                                const color = {}; 
                                for (let i = 0; i < vertices.length; i++) { 
                                    color[vertices[i]] = Colors.WHITE; 
                                } 
                                return color; 
                            };

                            class Queue{
                                constructor(){
                                    this.count=0;
                                    this.lowestCount=0;
                                    this.items={};
                                }

                                enqueue(item){
                                    this.items[this.count]=item;
                                    this.count++;
                                }

                                dequeue(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    let res=this.items[this.lowestCount];
                                    delete this.items[this.lowestCount];
                                    this.lowestCount++;
                                    return res;
                                }

                                peek(){
                                    if(this.isEmpty()){
                                        return undefined;
                                    }
                                    return this.items[this.lowestCount];
                                }
                                
                                isEmpty(){
                                    return this.size()===0;
                                }

                                size(){
                                    return this.count-this.lowestCount;
                                }

                                clear(){
                                    this.count=0;
                                    this.lowestCount=0;
                                    this.items={};
                                }

                                toString(){
                                    if(this.isEmpty()){
                                        return "";
                                    }
                                    let str=`${this.items[this.lowestCount]}`;
                                    for(let i = this.lowestCount+1; i < this.count ; i++){
                                        str=`${str},${this.items[i]}`;
                                    }
                                    return str;
                                }
                            }

                            const breadthFirstSearch = (graph, startVertex, callBack) => {
                                const vertices = graph.getVertices();
                                const adjList = graph.getAdjList();
                                const color = initializeColor(vertices);
                                const queue = new Queue();
                                queue.enqueue(startVertex);

                                while(!queue.isEmpty()){
                                    const u = queue.dequeue();
                                    const neighbors = adjList.get(u);
                                    color[u] = Colors.GREY;
                                    for(let i=0; i < neighbors.length; i++){
                                        const w = neighbors[i];
                                        if(color[w] === Colors.WHITE){
                                            color[w] = Colors.GREY;
                                            queue.enqueue(w);
                                        }
                                    }
                                    color[u] = Colors.BLACK;
                                    if(callBack){
                                        callBack(u)
                                    }
                                }
                            }

                            const BFS = (graph, startVertex) => {
                                const vertices = graph.getVertices();
                                const adjList = graph.getAdjList();
                                const color = initializeColor(vertices);
                                const queue = new Queue();
                                const distances = {};
                                const predecessors = {};
                                queue.enqueue(startVertex);

                                for(let i = 0; i < vertices.length; i++){
                                    distance[vertices[i]] = 0;
                                    predecessors[vertices[i]] = null;
                                }

                                while(!queue.isEmpty()){
                                    const u = queue.dequeue();
                                    const neighbors = adjList.get(u);
                                    color[u] = Colors.GREY;
                                    for(let i=0; i < neighbors.length; i++){
                                        const w = neighbors[i];
                                        if(color[w] === Colors.WHITE){
                                            color[w] = Colors.GREY;
                                            distances[w] = distances[u]+1;
                                            predecessors[w] = u;
                                            queue.enqueue(w);
                                        }
                                    }
                                    color[u] = Colors.BLACK;
                                }
                                return {
                                    distances,
                                    predecessors
                                }
                            }

                            const depthFirstSearch = (graph, callback) => {
                                const vertices = graph.getVertices();
                                const adjList = graph.getAdjList();
                                const color = initializeColor(vertices);

                                for(let i = 0; i < vertices.length; i++){
                                    if(color[vertices[i]] === Colors.WHITE){
                                        depthFirstSearchVisit(vertices[i], color, adjList, callback)
                                    }
                                }
                            }

                            const depthFirstSearchVisit = (u, color, adjList, callback) => {
                                color[u]= Colors.GREY;
                                if(callback){
                                    callback(u);
                                }
                                const neighbors = adjList.get(u);                    
                                for(let i = 0 ; i < neighbors.length; i++){
                                    const w = neighbors[i];
                                    if(color[w] === Colors.WHITE){
                                        depthFirstSearchVisit(w,color,adjList, callback);
                                    }
                                }
                                color[u] = Colors.BLACK;
                            }

                            const DFS = (graph) => {
                                const vertices = graph.getVertices();
                                const adjList = graph.getAdjList();
                                const color = initializeColor(vertices);
                                const d = {};
                                const f = {};
                                const p = {};
                                const time = { count: 0 };
                                for(let i = 0; i < vertices.length; i++){
                                    f[vertices[i]] = 0; 
                                    d[vertices[i]] = 0; 
                                    p[vertices[i]] = null;
                                }
                                for(let i = 0; i < vertices.length; i++){
                                    if(color[vertices[i]] === Colors.WHITE){
                                        DFSVisit(vertices[i], color ,d ,f ,p , adjList, callback)
                                    }
                                }
                                return {
                                    discovery: d,
                                    finished: f,
                                    predecessors: p
                                };
                            }

                            const DFSVisit = (u, color, d, f, p, time, adjList) => {
                                color[u] = Colors.GREY;
                                d[u] = ++time.count;
                                const neighbors = adjList.get(u);                    
                                for(let i = 0 ; i < neighbors.length; i++){
                                    const w = neighbors[i];
                                    if(color[w] === Colors.WHITE){
                                        p[w] = u;
                                        depthFirstSearchVisit(w,color,adjList, callback);
                                    }
                                }
                                color[u] = Colors.BLACK;
                                f[u] = ++time.count;
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>最短路径Dijkstra 算法、Floyd-Warshall 算法：</p>
                    <p>
                        <code>
                            let graph = [
                            [0, 2, 4, 0, 0, 0], 
                            [0, 0, 1, 4, 2, 0], 
                            [0, 0, 0, 0, 3, 0], 
                            [0, 0, 0, 0, 0, 2], 
                            [0, 0, 0, 3, 0, 2], 
                            [0, 0, 0, 0, 0, 0],
                            ];
                            const INF = Number.MAX_SAFE_INTEGER;
                            const dijkstra = (graph, src) => { 
                                const dist = []; 
                                const visited = []; 
                                const { length } = graph; 
                                for (let i = 0; i < length; i++) {
                                    dist[i] = INF; 
                                    visited[i] = false; 
                                } 
                                dist[src] = 0;
                                for (let i = 0; i < length - 1; i++) {
                                    const u = minDistance(dist, visited);
                                    visited[u] = true;
                                    for (let v = 0; v < length; v++) { 
                                        if (!visited[v] && graph[u][v] !== 0 && dist[u] !== INF && dist[u] + graph[u][v] < dist[v]) {
                                            dist[v] = dist[u] + graph[u][v];
                                        } 
                                    } 
                                } 
                                return dist;
                            };

                            const minDistance = (dist, visited) => { 
                                let min = INF; 
                                let minIndex = -1; 
                                for (let v = 0; v < dist.length; v++) { 
                                    if (visited[v] === false && dist[v] <= min) { 
                                        min = dist[v];
                                        minIndex = v;
                                    } 
                                }
                                return minIndex; 
                            };

                            const floydWarshall = graph => { 
                                const dist = []; 
                                const { length } = graph; 
                                for (let i = 0; i < length; i++) {
                                    dist[i] = []; 
                                    for (let j = 0; j < length; j++) { 
                                        if (i === j) { 
                                            dist[i][j] = 0;
                                        } else if (!isFinite(graph[i][j])) { 
                                            dist[i][j] = Infinity;
                                        } else { 
                                            dist[i][j] = graph[i][j];
                                        } 
                                    } 
                                } 
                                for (let k = 0; k < length; k++) { // {5} 
                                    for (let i = 0; i < length; i++) { 
                                        for (let j = 0; j < length; j++) { 
                                            if (dist[i][k] + dist[k][j] < dist[i][j]) {
                                                dist[i][j] = dist[i][k] + dist[k][j];
                                            }
                                        } 
                                    } 
                                } 
                                return dist; 
                            };
                        </code>
                    </p>
                </li>
                <li>
                    <p>最小生成树Prim算法、Kruskal算法：</p>
                    <p>
                        <code>
                            const graph = [[0, 2, 4, 0, 0, 0], 
                                        [2, 0, 2, 4, 2, 0], 
                                        [4, 2, 0, 0, 3, 0], 
                                        [0, 4, 0, 0, 3, 2], 
                                        [0, 2, 3, 3, 0, 2], 
                                        [0, 0, 0, 2, 2, 0]];
                            const INF = Number.MAX_SAFE_INTEGER; 
                            const prim = graph => { 
                                const parent = []; 
                                const key = []; 
                                const visited = []; 
                                const { length } = graph; 
                                for (let i = 0; i < length; i++) {
                                    key[i] = INF; 
                                    visited[i] = false; 
                                } 
                                key[0] = 0;
                                parent[0] = -1; 
                                for (let i = 0; i < length - 1; i++) {
                                    const u = minKey(graph, key, visited);
                                    visited[u] = true; 
                                    for (let v = 0; v < length; v++) { 
                                        if (graph[u][v] && !visited[v] && graph[u][v] < key[v]) {
                                            parent[v] = u; 
                                            key[v] = graph[u][v];
                                        } 
                                    } 
                                } 
                                return parent;
                            };

                            const minKey = (graph,dist, visited) => { 
                                let min = INF; 
                                let minIndex = -1; 
                                for (let v = 0; v < dist.length; v++) { 
                                    if (visited[v] === false && dist[v] <= min) { 
                                        min = dist[v];
                                        minIndex = v;
                                    } 
                                }
                                return minIndex; 
                            };

                            const kruskal = graph => { 
                                const { length } = graph; 
                                const parent = []; 
                                let ne = 0; 
                                let a; let b; let u; let v; 
                                const cost = initializeCost(graph); 
                                while (ne < length - 1) { 
                                    for (let i = 0, min = INF; i < length; i++){
                                        for (let j = 0; j < length; j++) { 
                                            if (cost[i][j] < min) { 
                                                min = cost[i][j]; 
                                                a = u = i; 
                                                b = v = j; 
                                            } 
                                        } 
                                    } 
                                    u = find(u, parent); 
                                    v = find(v, parent); 
                                    if (union(u, v, parent)) { // {6} 
                                        ne++; 
                                    } 
                                    cost[a][b] = cost[b][a] = INF;
                                } 
                                return parent; 
                            };

                            const initializeCost = (graph)=>{
                                return JSON.parse(JSON.stringify(graph))
                            };

                            const find = (i, parent) => { 
                                while (parent[i]) { 
                                    i = parent[i]; 
                                } 
                                return i; 
                            };

                            const union = (i, j, parent) => { 
                                if (i !== j) { 
                                    parent[j] = i; 
                                    return true; 
                                } 
                                return false; 
                            };
                        </code>
                    </p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第十三章：排序和搜索算法</h2>
            <ul>
                <li>
                    <p>冒泡排序：</p>
                    <p>
                        <code>
                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            function bubbleSort(array, compareFn = defaultCompare){
                                let res = [...array];
                                const { length } = array;
                                for(let i = 0; i < length; i++){
                                    for(let j = 0; j < length - i - 1; j++){
                                        if(compareFn(res[j],res[j+1]) === Compare.BIGGER_THAN){
                                            [res[j],res[j+1]] = [res[j+1],res[j]];
                                        }
                                    }
                                }
                                return res;
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>选择排序：</p>
                    <p>
                        <code>
                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            function selectionSort(array, compareFn = defaultCompare){
                                let res = [...array];
                                const { length } = array;
                                for(let i = 0; i < length; i++){
                                    let target = i;
                                    for(let j = i+1; j < length; j++){
                                        if(defaultCompare(res[target], res[j]) === Compare.BIGGER_THAN){
                                            target=j;
                                        }
                                    }

                                    if(i != target){
                                        [res[i], res[target]] = [res[target], res[i]];
                                    }
                                }
                                return res;
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>插入排序：</p>
                    <p>
                        <code>
                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            function insertionSort(array, compareFn = defaultCompare){
                                let res = [...array];
                                const { length } = array;
                                for(let i = 1; i < length; i++){
                                    let currentValue= res[i];
                                    let previousIndex = i-1;
                                    
                                    while(previousIndex >= 0 && compareFn(currentValue, res[previousIndex]) === Compare.LESS_THAN){
                                        res[previousIndex + 1] = res[previousIndex];
                                        previousIndex--;
                                    }

                                    res[previousIndex + 1] = currentValue;
                                }
                                return res;
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>归并排序：</p>
                    <p>
                        <code>
                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            function mergeSort(array, compareFn = defaultCompare) {
                                if(array.length > 1){
                                    const {length} = array;
                                    const middle = Math.floor(length / 2);
                                    const left = mergeSort(array.slice(0, middle), compareFn);
                                    const right = mergeSort(array.slice(middle,length), compareFn);
                                    array = merge(left, right, compareFn);
                                }
                                return array;
                            }

                            function merge(left, right, compareFn){
                                let i = 0;
                                let j = 0;
                                const result = [];
                                while(i < left.length && j < right.length){
                                    result.push(compareFn(left[i], right[j]) === Compare.LESS_THAN ? left[i++]: right[j++])
                                }
                                return result.concat(i < left.length ? left.slice(i) : right.slice(j));
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>快速排序：</p>
                    <p>
                        <code>
                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            function quickSort(array, compareFn = defaultCompare){
                                if(array.length <=1){
                                    return array;
                                }
                                const middleIndex= Math.floor(array.length / 2);
                                const middleValue= array.splice(middleIndex,1)[0];
                                const left =[];
                                const right =[];
                                for(let i = 0; i < array.length; i++){         
                                    compareFn(array[i], middleValue) === Compare.LESS_THAN ? left.push(array[i]) : right.push(array[i]);
                                }
                                return [...quickSort(left,compareFn), middleValue, ...quickSort(right,compareFn)];
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>计数排序：</p>
                    <p>
                        <code>
                            function countingSort(array){
                                if(array.length < 2){
                                    return array;
                                }

                                const maxValue = Math.max(...array);
                                const counts = new Array(maxValue + 1);
                                array.forEach((element) => {
                                    if(!counts[element]){
                                        counts[element]=0;
                                    }
                                    counts[element]++;
                                })

                                let sortedIndex = 0;
                                counts.forEach((count, index) => {
                                    while(count>0){
                                        array[sortedIndex] = index;
                                        sortedIndex++;
                                        count--;
                                    }
                                })
                                return array;
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>桶排序：</p>
                    <p>
                        <code>
                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            function insertionSort(array, compareFn = defaultCompare){
                                let res = [...array];
                                const { length } = array;
                                for(let i = 1; i < length; i++){
                                    let currentValue= res[i];
                                    let previousIndex = i-1;
                                    
                                    while(previousIndex >= 0 && compareFn(currentValue, res[previousIndex]) === Compare.LESS_THAN){
                                        res[previousIndex + 1] = res[previousIndex];
                                        previousIndex--;
                                    }

                                    res[previousIndex + 1] = currentValue;
                                }
                                return res;
                            }

                            function bucketSort(array, bucketSize = 5){
                                if(array.length < 2){
                                    return array;
                                }
                                const buckets = createBuckets(array, bucketSize);
                                return sortBuckets(buckets);
                            }

                            function createBuckets(array, bucketSize){
                                const minValue = Math.min(...array);
                                const maxValue = Math.max(...array);
                                
                                const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;
                                const buckets = [];
                                for(let i = 0; i < bucketCount; i++){
                                    buckets[i]=[];
                                }
                                for(let i = 0; i < array.length; i++){
                                    const bucketIndex = Math.floor((array[i] - minValue) / bucketSize);
                                    buckets[bucketIndex].push(array[i]);
                                }
                                return buckets;
                            }

                            function sortBuckets(buckets){
                                const sortedArray = [];
                                for(let i = 0; i < buckets.length; i++){
                                    if(buckets[i] != null){
                                        let res = insertionSort(buckets[i]);
                                        sortedArray.push(...res);
                                    }
                                }
                                return sortedArray;
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>基数排序：</p>
                    <p>
                        <code>
                            function radixSort(array, radixBase = 10){
                                if(array.length < 2){
                                    return array;
                                }
                                const minValue = Math.min(...array);
                                const maxValue = Math.max(...array);
                                let significantDigit = 1;
                                while ((maxValue - minValue) / significantDigit >= 1) {
                                    array = countingSortForRadix(array, radixBase, significantDigit, minValue); 
                                    significantDigit *= radixBase;
                                } 
                                return array;
                            }

                            function countingSortForRadix(array, radixBase, significantDigit, minValue) { 
                                let bucketsIndex; 
                                const buckets = []; 
                                const aux = []; 
                                for (let i = 0; i < radixBase; i++) {
                                    buckets[i] = 0; 
                                } 
                                for (let i = 0; i < array.length; i++) {
                                    bucketsIndex = Math.floor(((array[i] - minValue) / significantDigit) % radixBase);
                                    buckets[bucketsIndex]++;
                                } 
                                for (let i = 1; i < radixBase; i++) {
                                    buckets[i] += buckets[i - 1]; 
                                } 
                                for (let i = array.length - 1; i >= 0; i--) {
                                    bucketsIndex = Math.floor(((array[i] - minValue) / significantDigit) % radixBase);
                                    aux[--buckets[bucketsIndex]] = array[i];
                                } 
                                for (let i = 0; i < array.length; i++) {
                                    array[i] = aux[i]; 
                                } 
                                return array; 
                            }

                        </code>
                    </p>
                </li>
           
                <li>
                    <p>顺序搜索：</p>
                    <p>
                        <code>
                            function sequentialSearch(array, value){
                                for(let i = 0; i < array.length; i++){
                                    if(array[i]===value){
                                        return i;
                                    }
                                }
                                return -1;
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>二分搜索：</p>
                    <p>
                        <code>
                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            function quickSort(array, compareFn = defaultCompare){
                                if(array.length <=1){
                                    return array;
                                }
                                const middleIndex= Math.floor(array.length / 2);
                                const middleValue= array.splice(middleIndex,1)[0];
                                const left =[];
                                const right =[];
                                for(let i = 0; i < array.length; i++){         
                                    compareFn(array[i], middleValue) === Compare.LESS_THAN ? left.push(array[i]) : right.push(array[i]);
                                }
                                return [...quickSort(left,compareFn), middleValue, ...quickSort(right,compareFn)];
                            }

                            function binarySearch(array,value){
                                let sortedArray= quickSort(array);
                                let low = 0;
                                let high = sortedArray.length - 1;
                                while(low <= high){
                                    const mid = Math.floor((low + high) / 2);
                                    const midValue = sortedArray[mid];
                                    if(defaultCompare(value, midValue) === Compare.BIGGER_THAN){
                                        low = mid + 1;
                                    }else if (defaultCompare(value, midValue) === Compare.LESS_THAN){
                                        high = mid - 1;
                                    }else{
                                        return mid
                                    }
                                }
                                return -1;
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>内插搜索：</p>
                    <p>
                        <code>
                            function interpolationSearch(array,value){
                                const {length} = array;
                                let low = 0;
                                let high = length - 1;
                                let position = -1;
                                let delta = -1;
                                while(low < high){
                                    delta = (value - array[low]) / (array[high] - array[low]);
                                    position = low + Math.floor((high - low ) * delta);
                                    if(array[position] === value){
                                        return position;
                                    }
                                    if(array[position] < value){
                                        low = position + 1;
                                    } else{
                                        high = position - 1;
                                    }
                                }
                                return -1;
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>随机算法Fisher-Yates随机：</p>
                    <p>
                        <code>
                            function shuffle(array) { 
                                for (let i = array.length - 1; i > 0; i--) { 
                                    const randomIndex = Math.floor(Math.random() * (i + 1)); 
                                    [array[i], array[randomIndex]] = [array[randomIndex], array[i]];
                                } 
                                return array; 
                            }
                        </code>
                    </p>
                </li>
            </ul>
        </section>
        <section>
            <h2>第十四章：算法设计与技巧</h2>
            <ul>
                <li>
                    <p>分而治之：</p>
                    <p>
                        分解-解决-合并<br/>
                        <code>
                            const Compare = {
                                LESS_THAN: -1,
                                BIGGER_THAN: 1
                            }
                            
                            function defaultCompare(a,b){
                                if(a === b){
                                    return 0;
                                }
                                return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
                            }

                            function quickSort(array, compareFn = defaultCompare){
                                if(array.length <=1){
                                    return array;
                                }
                                const middleIndex= Math.floor(array.length / 2);
                                const middleValue= array.splice(middleIndex,1)[0];
                                const left =[];
                                const right =[];
                                for(let i = 0; i < array.length; i++){         
                                    compareFn(array[i], middleValue) === Compare.LESS_THAN ? left.push(array[i]) : right.push(array[i]);
                                }
                                return [...quickSort(left,compareFn), middleValue, ...quickSort(right,compareFn)];
                            }

                            function binarySearch(array,value){
                                const sortedArray = quickSort(array);
                                let low = 0;
                                let high = sortedArray.length - 1;
                                return binarySearchRecursive(sortedArray, value, low, high);
                            }

                            function binarySearchRecursive(array,value,low,high){
                                const middle = Math.floor((low + high) / 2);
                                const middleValue= array[middle];
                                if( middleValue > value){
                                    high = middle - 1;
                                    return binarySearchRecursive(array,value,low,high)
                                }else if( middleValue < value){
                                    low = middle + 1;
                                    return binarySearchRecursive(array,value,low,high)
                                }else{
                                    return middle;
                                }

                                return -1;
                            }
                        </code>
                    </p>
                </li>
                <li>
                    <p>动态规划</p>
                    <p>
                        (1) 定义子问题；<br>
                        (2) 实现要反复执行来解决子问题的部分（这一步要参考前一节讨论的递归的步骤）；<br>
                        (3) 识别并求解出基线条件。<br>
                    </p>
                    <p>最少硬币找零问题：</p>
                    <p>
                        <code>
                            function miniCoinChange(coins, amount){
                                const cache = [];
                                const makeChange = (value) => {
                                    if(!value || value < 0){
                                        return [];
                                    }
                                    if(cache[value]){
                                        return cache[value];
                                    }
                                    let min=[];
                                    let newMin;
                                    let newAmount;
                                    for(let i=0; i < coins.length; i++){
                                        const coin = coins[i];
                                        newAmount = value - coin;
                                        if(newAmount >= 0){
                                            newMin = makeChange(newAmount);
                                        }
                                        if(newAmount >= 0 && (newMin.length < min.length - 1 || !min.length) && (newMin.length || !newAmount)){
                                            min = [coin].concat(newMin);
                                            console.log('new Min ' + min + ' for ' + amount);
                                        }
                                    }
                                    return (cache[value] = min);
                                }
                                return makeChange(amount);
                            }
                            miniCoinChange([1,2,5,10,20],38)
                        </code>
                    </p>
                    <p>背包问题：</p>
                    <p>
                        <code>
                            function knapSack(capacity, weights, values, n) { 
                                const kS = []; 
                                for (let i = 0; i <= n; i++) {
                                    kS[i] = []; 
                                } 
                                for (let i = 0; i <= n; i++) { 
                                    for (let w = 0; w <= capacity; w++) { 
                                        if (i === 0 || w === 0) {
                                            kS[i][w] = 0; 
                                        } else if (weights[i - 1] <= w) {
                                            const a = values[i - 1] + kS[i - 1][w - weights[i - 1]]; 
                                            const b = kS[i - 1][w]; 
                                            kS[i][w] = a > b ? a : b;
                                        } else { 
                                            kS[i][w] = kS[i - 1][w];
                                        } 
                                    } 
                                }
                                findValues(n, capacity, kS, weights, values);
                                return kS[n][capacity];
                            }

                            function findValues(n, capacity, kS, weights, values) { 
                                let i = n;
                                let k = capacity; 
                                console.log('构成解的物品：'); 
                                while (i > 0 && k > 0) { 
                                    if (kS[i][k] !== kS[i - 1][k]) { 
                                        console.log(`物品 ${i} 可以是解的一部分 w,v: ${weights[i - 1]}, ${values[i - 1]}`); 
                                        i--; 
                                        k -= kS[i][k]; 
                                    } else { 
                                        i--; 
                                    } 
                                } 
                            }
                            const values = [3,4,5], 
                            weights = [2,3,4], 
                            capacity = 5, 
                            n = values.length; 
                            console.log(knapSack(capacity, weights, values, n))
                        </code>
                    </p>
                    <p>最长公共子序列：</p>
                    <p>
                        <code>
                            function printSolution(solution, wordX, m, n) { 
                                let a = m; 
                                let b = n; 
                                let x = solution[a][b]; 
                                let answer = ''; 
                                while (x !== '0') { 
                                    if (solution[a][b] === 'diagonal') { 
                                        answer = wordX[a - 1] + answer; 
                                        a--; 
                                        b--; 
                                    } else if (solution[a][b] === 'left') { 
                                        b--; 
                                    } else if (solution[a][b] === 'top') { 
                                        a--; 
                                    } 
                                    x = solution[a][b]; 
                                } 
                                console.log('lcs: ' + answer); 
                            }

                            function lcs(wordX, wordY) { 
                                const m = wordX.length; 
                                const n = wordY.length; 
                                const l = []; 
                                let solution =[];
                                for (let i = 0; i <= m; i++) { 
                                    l[i] = [];
                                    solution[i] = [];
                                    for (let j = 0; j <= n; j++) { 
                                        l[i][j] = 0;
                                        solution[i][j] = '0';
                                    } 
                                } 
                                for (let i = 0; i <= m; i++) { 
                                    for (let j = 0; j <= n; j++) { 
                                        if (i === 0 || j === 0) { 
                                            l[i][j] = 0; 
                                        } else if (wordX[i - 1] === wordY[j - 1]) { 
                                            l[i][j] = l[i - 1][j - 1] + 1;
                                            solution[i][j] = 'diagonal';
                                        } else { 
                                            const a = l[i - 1][j]; 
                                            const b = l[i][j - 1]; 
                                            l[i][j] = a > b ? a : b;
                                            solution[i][j]=(l[i][j] == l[i-1][j]) ? 'top' : 'left';
                                        } 
                                    } 
                                } 
                                printSolution(solution, wordX, m, n);
                                return l[m][n];
                            }

                            lcs(["a","c","c","b","c","d","a","e"],["a","b","c","d","e"])
                        </code>
                    </p>
                    <p>矩阵链相乘：</p>
                    <p>
                        <code>
                            function matrixChainOrder(p) { 
                                const n = p.length; 
                                const m = []; 
                                const s = []; 
                                for (let i = 1; i <= n; i++) { 
                                    m[i] = []; 
                                    m[i][i] = 0; 
                                } 
                                for (let l = 2; l < n; l++) { 
                                    for (let i = 1; i <= (n - l) + 1; i++) { 
                                        const j = (i + l) - 1; 
                                        m[i][j] = Number.MAX_SAFE_INTEGER; 
                                        for (let k = i; k <= j - 1; k++) { 
                                            const q = m[i][k] + m[k + 1][j] + ((p[i - 1] * p[k]) * p[j]); // {1} 
                                            if (q < m[i][j]) { 
                                                m[i][j] = q; // {2} 
                                            } 
                                        } 
                                    } 
                                } 
                                return m[1][n - 1]; // {3} 
                            }

                            const p = [10, 100, 5, 50, 1]; 
                            console.log(matrixChainOrder(p));
                        </code>
                    </p>
                </li>
                <li>
                    <p>贪心算法：</p>
                    <p>最少硬币找零问题：</p>
                    <p>
                        <code>
                            function(coins, amount){
                                let change =[];
                                let total =0;
                                for(let i = coins.length - 1; i >= 0; i--){
                                    const coin = coins[i];
                                    while(total + coin <= amount){
                                        total += coin;
                                        change.push(coin);
                                    }
                                }
                                return change;
                            }
                        </code>
                    </p>
                    <p>分数背包问题：</p>
                    <p>
                        <code>
                            function knapSack(capacity, weights, values) { 
                                const n = values.length; 
                                let load = 0; 
                                let val = 0; 
                                for (let i = 0; i < n && load < capacity; i++) { // {1}     
                                    if (weights[i] <= capacity - load) { // {2} 
                                        val += values[i]; 
                                        load += weights[i]; 
                                    } else { 
                                        const r = (capacity - load) / weights[i]; // {3} 
                                        val += r * values[i]; 
                                        load += weights[i]; 
                                    } 
                                } 
                                return val; 
                            } 
                        </code>
                    </p>
                </li>
                <li>
                    <p>回溯算法：</p>
                    <p>
                        迷宫老鼠问题：
                    </p>
                    <p>
                        <code>
                            function ratInAMaze(maze) { 
                                const solution = []; 
                                for (let i = 0; i < maze.length; i++) {
                                    solution[i] = []; 
                                    for (let j = 0; j < maze[i].length; j++) { 
                                        solution[i][j] = 0; 
                                    } 
                                } 
                                if (findPath(maze, 0, 0, solution) === true) {
                                    return solution; 
                                } 
                                return 'NO PATH FOUND';
                            }

                            function findPath(maze, x, y, solution) { 
                                const n = maze.length; 
                                if (x === n - 1 && y === n - 1) {
                                    solution[x][y] = 1; 
                                    return true; 
                                } 
                                if (isSafe(maze, x, y) === true) {
                                    solution[x][y] = 1;
                                    if (findPath(maze, x + 1, y, solution)) {
                                        return true; 
                                    } 
                                    if (findPath(maze, x, y + 1, solution)) {
                                        return true; 
                                    } 
                                    solution[x][y] = 0;
                                    return false; 
                                } 
                                return false;
                            }

                            function isSafe(maze, x, y) { 
                                const n = maze.length;
                                if (x >= 0 && y >= 0 && x < n && y < n && maze[x][y] !== 0) { 
                                    return true;
                                } 
                                return false; 
                            }

                            const maze = [ 
                            [1, 0, 0, 0], 
                            [1, 1, 1, 1], 
                            [0, 0, 1, 0], 
                            [0, 1, 1, 1] 
                            ]; 
                            console.log(ratInAMaze(maze));
                        </code>
                    </p>
                    <p>数独解题器：</p>
                    <p>
                        <code>
                            function sudokuSolver(matrix) { 
                                if (solveSudoku(matrix) === true) { 
                                    return matrix; 
                                } 
                                return '问题无解！'; 
                            }

                            const UNASSIGNED = 0; 
                            function solveSudoku(matrix) { 
                                let row = 0; 
                                let col = 0; 
                                let checkBlankSpaces = false; 
                                for (row = 0; row < matrix.length; row++) {
                                    for (col = 0; col < matrix[row].length; col++) { 
                                        if (matrix[row][col] === UNASSIGNED) { 
                                        checkBlankSpaces = true;
                                        break; 
                                        } 
                                    } 
                                    if (checkBlankSpaces === true) {
                                        break; 
                                    } 
                                } 
                                if (checkBlankSpaces === false) { 
                                    return true;
                                } 
                                for (let num = 1; num <= 9; num++) {
                                    if (isSafe(matrix, row, col, num)) {
                                        matrix[row][col] = num;
                                        if (solveSudoku(matrix)) {
                                            return true; 
                                        } 
                                        matrix[row][col] = UNASSIGNED;
                                    } 
                                } 
                                return false; 
                            }

                            function isSafe(matrix, row, col, num) { 
                                return ( 
                                !usedInRow(matrix, row, num) && 
                                !usedInCol(matrix, col, num) && 
                                !usedInBox(matrix, row - (row % 3), col - (col % 3), num) 
                                ); 
                            }

                            function usedInRow(matrix, row, num) { 
                                for (let col = 0; col < matrix.length; col++) {
                                    if (matrix[row][col] === num) { 
                                        return true; 
                                    } 
                                } 
                                return false; 
                            } 
                            function usedInCol(matrix, col, num) { 
                                for (let row = 0; row < matrix.length; row++) { 
                                    if (matrix[row][col] === num) { 
                                        return true; 
                                    } 
                                } 
                                return false; 
                            } 
                            function usedInBox(matrix, boxStartRow, boxStartCol, num) { 
                                for (let row = 0; row < 3; row++) { 
                                    for (let col = 0; col < 3; col++) { 
                                        if (matrix[row + boxStartRow][col + boxStartCol] === num) {
                                            return true; 
                                        } 
                                    } 
                                } 
                                return false; 
                            }
                            const sudokuGrid = [ 
                            [5, 3, 0, 0, 7, 0, 0, 0, 0], 
                            [6, 0, 0, 1, 9, 5, 0, 0, 0], 
                            [0, 9, 8, 0, 0, 0, 0, 6, 0], 
                            [8, 0, 0, 0, 6, 0, 0, 0, 3], 
                            [4, 0, 0, 8, 0, 3, 0, 0, 1], 
                            [7, 0, 0, 0, 2, 0, 0, 0, 6], 
                            [0, 6, 0, 0, 0, 0, 2, 8, 0], 
                            [0, 0, 0, 4, 1, 9, 0, 0, 5], 
                            [0, 0, 0, 0, 8, 0, 0, 7, 9] 
                            ]; 
                            console.log(sudokuSolver(sudokuGrid));
                        </code>
                    </p>
                </li>
                <li>函数式编程：</li>
                <li>
                    函数式编程的主要目标是描述数据，以及要对数据应用的转换。<br>
                    在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。<br>
                    函数和数据集合是函数式编程的核心。<br>
                    在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。<br>
                    在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。<br>
                </li>
            </ul>
        </section>
        <section>
            <h2>第十五章：算法复杂度</h2>
            <ul>
                <li>
                    <p>大O表示法：算法消耗的时间</p>
                    <p>
                        O(1) 常数的 <br>
                        O(log(n)) 对数的 <br>
                        O((log(n))c) 对数多项式的 <br>
                        O(n) 线性的 <br>
                        O(n<sup>2</sup>) 二次的 <br>
                        O(n<sup>c</sup>) 多项式的 <br>
                        O(c<sup>n</sup>) 指数的
                    </p>
                </li>
                <li>
                    <p>NP完全理论概述：</p>
                    <p>
                        对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式）。
                        还有一类 NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多
                        项式时间内验证解是否正确，则计为 NP。
                        如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是
                        NP。然而，P = NP 是否成立，仍然不得而知。
                        NP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：
                        (1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；
                        (2) 所有的 NP 问题都能在多项式时间内归约为 L。
                    </p>
                </li>
            </ul>
        </section>
    </main>
</body>

</html>